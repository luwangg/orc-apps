package org.ietr.mpegh.part2.main.upSampling;
import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

unit UpSamplingFunctions :
	
	int N_SHIFT  				= 20-8;
	int I_OFFSET 				= (1 << (N_SHIFT - 1));
	int MAX_EDGE_CR 			= 2;
	int MAX_EDGE				= 4;
	int DEFAULT					= 0;
    int X2                      = 1;
    int X1_5                    = 2;
	int SNR						= 3;
	int MAX_PB_SIZE				= 64;						
	int MAX_EDGE_BUFFER_STRIDE	= ((MAX_PB_SIZE+20) * 2);
	int MAX_EDGE_BUFFER_SIZE	= ((MAX_PB_SIZE + 20) * (MAX_PB_SIZE+20) * 2);
	int NTAPS_LUMA = 8;
	int NTAPS_CHROMA = 4;
	int US_FILTER_PREC = 6;
	
	int(size=8) up_sample_filter_chroma[16][4]=
	[
    [  0,  64,   0,  0],
    [ -2,  62,   4,  0],
    [ -2,  58,  10, -2],
    [ -4,  56,  14, -2],
    [ -4,  54,  16, -2],
    [ -6,  52,  20, -2],
    [ -6,  46,  28, -4],
    [ -4,  42,  30, -4],
    [ -4,  36,  36, -4],
    [ -4,  30,  42, -4],
    [ -4,  28,  46, -6],
    [ -2,  20,  52, -6],
    [ -2,  16,  54, -4],
    [ -2,  14,  56, -4],
    [ -2,  10,  58, -2],
    [  0,   4,  62, -2]
	];

	int(size=8) up_sample_filter_luma[16][8]=
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [  0,  1,  -3,  63,   4,  -2,  1,  0],
    [ -1,  2,  -5,  62,   8,  -3,  1,  0],
    [ -1,  3,  -8,  60,  13,  -4,  1,  0],
    [ -1,  4, -10,  58,  17,  -5,  1,  0],
    [ -1,  4, -11,  52,  26,  -8,  3, -1],
    [ -1,  3,  -9,  47,  31, -10,  4, -1],
    [ -1,  4, -11,  45,  34, -10,  4, -1],
    [ -1,  4, -11,  40,  40, -11,  4, -1],
    [ -1,  4, -10,  34,  45, -11,  4, -1],
    [ -1,  4, -10,  31,  47,  -9,  3, -1],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [  0,  1,  -5,  17,  58, -10,  4, -1],
    [  0,  1,  -4,  13,  60,  -8,  3, -1],
    [  0,  1,  -3,   8,  62,  -5,  2, -1],
    [  0,  1,  -2,   4,  63,  -3,  1,  0]
	];

	int(size=8) up_sample_filter_luma_x2[2][8] = /*0 , 8 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  4, -11,  40,  40, -11,  4, -1]
	];

	int(size=8) up_sample_filter_luma_x1_5[3][8] = /* 0, 11, 5 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [ -1,  4, -11,  52,  26,  -8,  3, -1]
	];

	int(size=8) up_sample_filter_chroma_x1_5[3][4]= /* 0, 11, 5 */
	[
    [  0,  64,   0,  0],
    [ -2,  20,  52, -6],
    [ -6,  52,  20, -2]
	];
	int(size=8) up_sample_filter_x1_5chroma[3][4]=
	[
    [  0,   4,  62, -2],
    [ -4,  30,  42, -4],
    [ -4,  54,  16, -2]
	];

	int(size=8) up_sample_filter_chroma_x2[2][4]=
	[
    [  0,  64,   0,  0],
    [ -4,  36,  36, -4]
	];

	int(size=8) up_sample_filter_chroma_x2_v[2][4]=
	[
    [ -2,  10,  58, -2],
    [ -6,  46,  28, -4]
	];

	function LumVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	function CroVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[4], int widthEL) --> int(size=16) :
		(pel[0]*coeff[0] + pel[widthEL]*coeff[1] + pel[widthEL*2]*coeff[2] + pel[widthEL*3]*coeff[3])
	end
	
	function LumVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width) --> int(size=16) :
		(pel[0]*coeff[0] + pel[width]*coeff[1] + pel[width*2]*coeff[2] + pel[width*3]*coeff[3] + pel[width*4]*coeff[4] + pel[width*5]*coeff[5] + pel[width*6]*coeff[6] + pel[width*7]*coeff[7])
	end
	
	function LumHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int offset) --> int(size=16) :
		(pel[-3 + offset]*coeff[0] + pel[-2 + offset]*coeff[1] + pel[-1 + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[1 + offset]*coeff[4] + pel[2 + offset]*coeff[5] + pel[3 + offset]*coeff[6] + pel[4 + offset]*coeff[7])
	end
	
	function CroHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int offset) --> int(size=16) :
		(pel[-1 + offset]*coeff[0] + pel[0 + offset]*coeff[1] + pel[1 + offset]*coeff[2] + pel[2 + offset]*coeff[3])
	end
	
	function LumVer_FILTER_Block(uint(size=8) pel [MAX_EDGE_BUFFER_SIZE], uint (size=8) coeff[8], int width, int offset) --> int(size=16) :
		(pel[-3*width + offset]*coeff[0] + pel[-2*width + offset]*coeff[1] + pel[-width + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[width + offset]*coeff[4] + pel[2*width + offset]*coeff[5] + pel[3*width + offset]*coeff[6] + pel[4*width + offset]*coeff[7])
	end
	
	function CroVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int width, int offset) --> int(size=16) :
		(pel[-width]*coeff[0] + pel[0]*coeff[1] + pel[width]*coeff[2] + pel[2*width]*coeff[3])
	end
	
	function LumHor_FILTER(uint(size=8) pel [8], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	procedure emulated_edge_up_h (uint(size=8) src[39*32], int linesize,
                                    int Enhscal[4],
                                    int block_w, int block_h, int bl_edge_left, int bl_edge_right, int shift)
  	begin
	    if(bl_edge_left < shift) then
	        foreach int i in 0 .. block_h - 1 do
	        	foreach int j in 0 .. shift - 1 do
	            	src[j + i * linesize] := src[shift + i * linesize];
	            end
	        end
	    end
	    
	    if(bl_edge_right<(shift+1)) then
	        foreach int i in 0 .. block_h - 1 do
	        	foreach int j in 0 .. shift do
	            	src[block_w + shift + j + i * linesize] := src[block_w -1 + shift + i * linesize]; // linesize = 39
	            end
	        end
	    end
	end
	
	procedure emulated_edge_up_v(int(size=16) src[MAX_EDGE_BUFFER_SIZE], int linesize, int Enhscal[4], int block_w, 
								 int block_h, int src_x, int bl_edge_up, int bl_edge_bottom, int wEL, int shift)
	var
	    int rightEndL  := wEL - (Enhscal[1] >> (if(shift=(MAX_EDGE_CR-1)) then 1 else 0 end)),
	    int leftStartL := (Enhscal[0]>> (if shift=(MAX_EDGE_CR-1) then 1 else 0 end)),
	    int src_offset := shift * linesize,
	    int dst_offset := shift * linesize  
    begin
	    if(bl_edge_up < shift)  then
	        foreach int i in 0 .. block_w - 1 do
	            foreach int j in bl_edge_up .. shift - 1 do
	                src[(-j-1)*linesize + dst_offset] := src[-bl_edge_up*linesize + src_offset];
	            end   
	            if( ((src_x+i) >= leftStartL) && ((src_x+i) <= rightEndL-2) ) then
	                src_offset := src_offset + 1;
	            end
	            dst_offset := dst_offset + 1;
	        end
	    
	    elsif(bl_edge_bottom < (shift+1) )    then
	        foreach int i in 0 .. block_w - 1 do
	            foreach int j in 0 .. shift+1 - 1 do
	                src[(block_h+j)*linesize + dst_offset] := src[(block_h-1)*linesize + src_offset];
	            end
	            if( ((src_x+i) >= leftStartL) && ((src_x+i) <= rightEndL-2) ) then
	                src_offset := src_offset + 1;
	            end
	            dst_offset := dst_offset + 1;
	        end
	    end
	end

	int UP_FILTER_INF[9]        = [2048, 2048, 32768, 32768, 2048, 10240, 32768, 32768, 1];
	int SCALING_FACTOR[2] = [512,512];
 /** int addXLum;		0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
 /* 
 	Enhscal {
	    int left_offset;	0
	    int right_offset;	1
	    int top_offset;		2
	    int bottom_offset;	3
	} HEVCWindow;
	* */

	procedure upsample_filter_block_luma_h_x2( int(size=16) dst[MAX_EDGE_BUFFER_SIZE], int _dststride, uint(size=8) src[39*32], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int x,
	    int(size=8) coeff[8],
	    int offset := 0
	begin
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma_x2[x&0x01][k];
	        end
	        offset := ((x-leftStartL)>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	            dst[i + j * _dststride] := LumHor_FILTER_Block(src, coeff, offset+3);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_h_x2 ( int(size=16) dst[32*16], int _dststride, uint(size=8) src[19*16], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int x,
	    int(size=8) coeff[4],
	    int offset := 0
	begin 
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartC, rightEndC);
	        foreach int k in 0 .. 3 do
	        	coeff[k]    := up_sample_filter_chroma_x2[x&0x01][k];
	        end
	        offset := (x>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	        	dst[i + j * _dststride] := CroHor_FILTER_Block(src, coeff, offset+1);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_luma_v_x2( uint(size=8) dst[64*64], int _dststride, int(size=16) src[MAX_EDGE_BUFFER_SIZE], int _srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
    var
	    int topStartL  := Enhscal[2],
	    int bottomEndL := heightEL - Enhscal[3],
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int y,
	    int(size=8) coeff[8],
    	int offset := 0
	begin
	    foreach int j in 0 .. block_h - 1 do
	    	y        := clip_i32(y_EL+j, topStartL, bottomEndL-1);
	        foreach int k in 0 .. 3 do
	        	coeff[k] := up_sample_filter_luma_x2[(y-topStartL)&0x01][k];
	        end	
	        offset  := (((y-topStartL)>>1)-y_BL)  * _srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[j*_dststride + i] := clip_i32( (LumVer_FILTER_Block(src, coeff, _srcstride, offset + 3 * _srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartL) && ((x_EL+i) <= rightEndL-2) ) then
	                offset := offset + 1;
	            end   
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_v_x2 (uint(size=8) dst[32*32], int dststride, int(size=16) src[32*19], int srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
	var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int topStartC  := Enhscal[2]>>1,
	    int bottomEndC := heightEL - (Enhscal[3]>>1),
	    int y,
	    int refPos16, 
	    int refPos,
	    int(size=8) coeff[4],
	    int offset := 0
	begin
	    foreach int j in 0 .. block_h -1 do
	        y        :=   clip_i32(y_EL+j, topStartC, bottomEndC-1);
	        refPos16 := ((( y - topStartC )* up_info[7] + up_info[5]) >> 12) - 4;
	        coeff    := up_sample_filter_chroma_x2_v[y&0x01];
	        refPos   := (refPos16>>4) - y_BL;
	        offset   := refPos  * srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[i + y* dststride + x_EL] := clip_i32( (CroVer_FILTER_Block(src, coeff, srcstride, offset + srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartC) && ((x_EL+i) <= rightEndC-2) ) then
	                offset := offset + 1; 
	            end
	        end
	    end
	end
	
	procedure upscale_mv_block (int(size=16) dst_mv [17][PICT_WIDTH/4][PICT_HEIGHT/4][2][2],int(size=16) src_mv [17][PICT_WIDTH/4][PICT_HEIGHT/4][2][2],
								int dst_pred_flag[17][PICT_WIDTH/4][PICT_HEIGHT/4],int src_pred_flag[17][PICT_WIDTH/4][PICT_HEIGHT/4], 
								int src_refIdxRef[17][PICT_WIDTH/4][PICT_HEIGHT/4][2], int(size=4) dst_refIdxRef[17][PICT_WIDTH/4][PICT_HEIGHT/4][2],
								int(size=16) src_pocRefList[17][MAX_NUM_SLICES][2][16],int(size=16)  dst_pocRefList[17][MAX_NUM_SLICES][2][16], int currentFrame, int currentSlice,
								int ctb_x, int ctb_y, int sps_width, int sps_height, int log2_min_pu_size, int bl_width, int bl_height, int log2_ctb_size,
								int sliceType, int sps_pic_conf_win_left_offset, int sps_pic_conf_win_top_offset,int up_info[9], int nuh_layer_id, int ScalingFactor[2][2] ) 
	var
	    int xEL := ctb_x,
	    int yEL := ctb_y,
	    int xBL, 
	    int yBL, 
	    int Ref_pre_unit, 
	    int pre_unit, 
	    int pre_unit_col,
	    int pic_width_in_min_pu   = sps_width  >> log2_min_pu_size,
	    int pic_height_in_min_pu  = sps_height >> log2_min_pu_size,
	    int pic_width_in_min_puBL = bl_width   >> log2_min_pu_size,
	    int ctb_size = 1 << log2_ctb_size,
	    int nb_list = if (sliceType=B_SLICE) then 2 else 1 end
	begin
	    while (yEL < ctb_y+ctb_size && yEL<sps_height) do
	        while(xEL < ctb_x+ctb_size && xEL<sps_width) do
	            xBL := (((clip_i32(xEL+8, 0, sps_width -1)  - sps_pic_conf_win_left_offset)* up_info[2] + (1<<15)) >> 16) + 4;
	            yBL := (((clip_i32(yEL+8, 0, sps_height -1) - sps_pic_conf_win_top_offset )*up_info[3] + (1<<15)) >> 16) + 4;
	            pre_unit := ((yEL>>log2_min_pu_size)*pic_width_in_min_pu) + (xEL>>log2_min_pu_size);
	            if(xBL < bl_width && yBL < bl_height) then
	                xBL := xBL >> 4;
	                xBL := xBL << (4-log2_min_pu_size); // 4 <==> xBL & 0xFFFFFFF0
	                yBL := yBL >> 4;
	                yBL := yBL << (4-log2_min_pu_size); // 4 <==> yBL & 0xFFFFFFF0
	                Ref_pre_unit := (yBL*pic_width_in_min_puBL)+xBL;
	                if src_pred_flag[currentFrame][xBL][yBL] != 0 then
	                    if (up_info[8] = SNR) then
	                        //memcpy(&refEL->tab_mvf[pre_unit], &refBL->tab_mvf[Ref_pre_unit], sizeof(MvField));
	                        // copy 4 elements of MVField
	                        dst_mv [currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)]       := [[src_mv [currentFrame][xBL][yBL][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1];
	                        dst_pred_flag[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := src_pred_flag[currentFrame][xBL][yBL];
	                        dst_refIdxRef[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := [src_refIdxRef[currentFrame][xBL][yBL][i]: for int i in 0 .. 1];
	                        dst_pocRefList[currentFrame][currentSlice]    := [[src_pocRefList[currentFrame][currentSlice][j][i]: for int i in 0 .. 15]: for int j in 0 .. 1]; // TODO: fix [16] reference list
	                        //dst_pocRefList[currentFrame][currentSlice] TODO: FIXME   := [[src_pocRefList[currentFrame][currentSlice][j][src_refIdxRef[currentFrame][xEL][yEL][i]]:for int i in 0 .. 1]: for int j in 0 .. 1];
	                    else
	                        foreach int list in 0 .. nb_list - 1 do
	                            dst_mv [currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)][list][0] := clip_i32( (ScalingFactor[nuh_layer_id][0] * src_mv [currentFrame][xBL][yBL][list][0] + 127 + (if (ScalingFactor[nuh_layer_id][0] * src_mv [currentFrame][xBL][yBL][list][0] < 0) then 1 else 0 end)) >> 8 , -32768, 32767);
	                            dst_mv [currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)][list][1] := clip_i32( (ScalingFactor[nuh_layer_id][1] * src_mv [currentFrame][xBL][yBL][list][1] + 127 + (if (ScalingFactor[nuh_layer_id][1] * src_mv [currentFrame][xBL][yBL][list][1] < 0) then 1 else 0 end)) >> 8, -32768, 32767);
	                            dst_refIdxRef[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)][list] := src_refIdxRef[currentFrame][xEL][yEL][list];
		                        dst_pocRefList[currentFrame][currentSlice][list] := [src_pocRefList[currentFrame][currentSlice][list][i]: for int i in 0 .. 15 ]; // TODO: fix [16] reference list
	                            dst_pred_flag[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := src_pred_flag[currentFrame][xEL][yEL];
	                            //dst_pocRefList[currentFrame][currentSlice]    := [[src_pocRefList[currentFrame][currentSlice][j][src_refIdxRef[currentFrame][xEL][yEL][i]]:for int i in 0 .. 1]: for int j in 0 .. 1];
	                        end
	                    end
	                else
	                    dst_mv [currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)]       := [[0: for int j in 0 .. 1]: for int i in 0 .. 1];
                        dst_pred_flag[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := 0;
                        dst_refIdxRef[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := [0: for int i in 0 .. 1];
	                        // TODO: missing poc 
					end
	            else
	                dst_mv [currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)]       := [[0: for int j in 0 .. 1]: for int i in 0 .. 1];
                    dst_pred_flag[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := 0;
                    dst_refIdxRef[currentFrame][(xEL>>log2_min_pu_size)][(yEL>>log2_min_pu_size)] := [0: for int i in 0 .. 1];
                        // TODO: missing poc 
	            end
	
	            if( ((xEL+1)>>log2_min_pu_size) < pic_width_in_min_pu && ((yEL+1)>>log2_min_pu_size) < pic_height_in_min_pu) then
	                //pre_unit_col := (((yEL+1)>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL+1)>>log2_min_pu_size);
	                dst_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)]       := 
	                [[src_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1];
	                
                    dst_pred_flag[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)] := 
                    src_pred_flag[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)];
                    
                    dst_refIdxRef[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)] := 
                    [src_refIdxRef[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)][i]: for int i in 0 .. 1];
	                        // TODO: missing poc 
	            end
	            if( ((xEL+1)>>log2_min_pu_size) < pic_width_in_min_pu) then
	                //pre_unit_col := ((yEL>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL+1)>>log2_min_pu_size);
	                dst_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)]       := 
	                [[src_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1];
	                
                    dst_pred_flag[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)] := 
                    src_pred_flag[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)];
                    
                    dst_refIdxRef[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)] := 
                    [src_refIdxRef[currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL)>>log2_min_pu_size)][i]: for int i in 0 .. 1];
                    
                    // TODO: missing poc
	            end
	            if( ((yEL+1)>>log2_min_pu_size) < pic_height_in_min_pu) then
	                //pre_unit_col := (((yEL+1)>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL)>>log2_min_pu_size);
	                dst_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)]       := 
	                [[src_mv [currentFrame][((xEL+1)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1];
	                
                    dst_pred_flag[currentFrame][((xEL)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)] := 
                    src_pred_flag[currentFrame][((xEL)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)];
                    
                    dst_refIdxRef[currentFrame][((xEL)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)] := 
                    [src_refIdxRef[currentFrame][((xEL)>>log2_min_pu_size)][((yEL+1)>>log2_min_pu_size)][i]: for int i in 0 .. 1];
                    // TODO: missing poc
	            end
	        	xEL :=xEL + 16;
	        end
	    	yEL := yEL + 16;
	    end
	end
		
	procedure upsample_base_layer_frame_Lum(uint(size=8)dstBufY[2304*4352], uint(size=8)srcBufY[2304*4352], uint(size=8) tempBufY[2304*4352],
											int widthBL, int heightBL, int strideBL, int widthEL, int heightEL, int strideEL,
											int leftStartL, int rightEndL, int topStartL, int bottomEndL,
											int leftStartC, int rightEndC, int topStartC, int bottomEndC)
	var 
/* UP_FILTER_INF
    int addXLum;	0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
//	    int widthBL :=  FrameBL->coded_width,
//	    int heightBL := FrameBL->coded_height,
//	    int strideBL := FrameBL->linesize[0],
//	    int widthEL :=  FrameEL->coded_width - Enhscal->left_offset - Enhscal->right_offset,
//	    int heightEL := FrameEL->coded_height - Enhscal->top_offset - Enhscal->bottom_offset,
//	    int strideEL := FrameEL->linesize[0],
//	    int pixel *srcBufY = (pixel*)FrameBL->data[0],
//	    int pixel *dstBufY = (pixel*)FrameEL->data[0],
//	    int short *tempBufY = Buffer[0],
	    uint(size=8) srcY [2304*4352],
	    uint(size=8) dstY [2304*4352],
	    uint(size=16) srcY1 [2304*4352],
	    uint(size=16) dstY1 [2304*4352],
	    
	    int refPos16 := 0,
	    int phase    := 0,
	    int refPos   := 0,
	    int(size=8) coeff[8],
//	    int leftStartL = Enhscal->left_offset,
//	    int rightEndL  = FrameEL->coded_width - Enhscal->right_offset,
//	    int topStartL  = Enhscal->top_offset,
//	    int bottomEndL = FrameEL->coded_height - Enhscal->bottom_offset,
	    uint(size=8) buffer[8],
	
	    int nShift = 20-8,
	    int iOffset = 1 << (nShift - 1),
	    uint(size=8) buffer1[8],
	
//	    int leftStartC = Enhscal->left_offset>>1,
//	    int rightEndC  = (FrameEL->coded_width>>1) - (Enhscal->right_offset>>1),
//	    int topStartC  = Enhscal->top_offset>>1,
//	    int bottomEndC = (FrameEL->coded_height>>1) - (Enhscal->bottom_offset>>1),
	    int x,
	    int y,
	    int cnt_dstY1 := 0,
	    int cnt_srcY1 := 0,
	    int cnt_dstY := 0,
	    int cnt_srcY := 0
	begin 
//	    widthEL   = FrameEL->coded_width;  //pcUsPic->getWidth ();
//	    heightEL  = FrameEL->coded_height; //pcUsPic->getHeight();
//	
//	    widthBL   = FrameBL->coded_width;
//	    heightBL  = FrameBL->coded_height <= heightEL ? FrameBL->coded_height:heightEL;  // min( FrameBL->height, heightEL);
		heightBL  := if(heightBL > heightEL) then heightBL else heightEL end;

	    foreach int i in 0 .. widthEL - 1 do
	        x := clip_i32(i, leftStartL, rightEndL);
	        refPos16 := (((x - leftStartL)*UP_FILTER_INF[2] + UP_FILTER_INF[0]) >> 12);
	        phase    := refPos16 & 15;
	        refPos   := refPos16 >> 4;
	        //coeff 	 := up_sample_filter_luma[phase];
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma[phase][k];
	        end
	        refPos := refPos - ((NTAPS_LUMA>>1) - 1);
	        //srcY   := srcBufY + refPos; TODO: define index
	        //dstY1  := tempBufY + i; TODO: define index
	        if(refPos < 0) then
	            foreach int j in 0 .. heightBL - 1 do
					foreach int k in 0 .. (-refPos)-1 do
	                	//memset(buffer, srcY[-refPos], -refPos);
	                	buffer[k] := srcY[cnt_srcY - refPos];
	               	end
	               	foreach int k in 0 .. (8+refPos)-1 do
	                	//memcpy(buffer-refPos, srcY-refPos, 8+refPos);
	                	buffer[k - refPos] := srcY[k + cnt_srcY - refPos];
	               	end
	               	//*dstY1 = LumHor_FILTER(buffer, coeff);
	                dstY1[cnt_dstY1] := LumHor_FILTER(buffer, coeff);
					//srcY += strideBL;
                	//dstY1 += widthEL;//strideEL;
	                cnt_srcY := cnt_srcY + strideBL;
	                cnt_dstY1 := cnt_dstY1 + widthEL;//strideEL;
	            end
			elsif (refPos+8 > widthBL ) then
                foreach int j in 0 .. heightBL - 1 do
                    foreach int k in 0 .. (widthBL-refPos)-1 do
	                	//memcpy(buffer, srcY, widthBL-refPos);
	                	buffer[k] := srcY[k + cnt_srcY];
	               	end
                    foreach int k in 0 .. (8-(widthBL-refPos))-1 do
	                	//memset(buffer+(widthBL-refPos), srcY[widthBL-refPos-1], 8-(widthBL-refPos));
	                	buffer[k+(widthBL-refPos)] := srcY[cnt_srcY + widthBL-refPos-1];
	               	end
                    
                    //*dstY1 = LumHor_FILTER(buffer, coeff);
                    dstY1[cnt_dstY1] := LumHor_FILTER(buffer, coeff);
                    //srcY += strideBL;
                	//dstY1 += widthEL;//strideEL;
                    cnt_srcY := cnt_srcY + strideBL;
	                cnt_dstY1 := cnt_dstY1 + widthEL;//strideEL;
            	end
			else
                foreach int j in 0 .. heightBL- 1 do
                	foreach int k in 0 .. 8-1 do
	                	//memcpy(buffer, srcY, 8);
	                	buffer[k] := srcY[k + cnt_srcY];
	               	end
                    dstY1[cnt_dstY1] := LumHor_FILTER(buffer, coeff);
                    cnt_srcY  := cnt_srcY + strideBL;
                    cnt_dstY1 := cnt_dstY1 + widthEL;//strideEL;
                end
        	end
	    end
	    foreach int j in 0 .. heightEL - 1 do
	        y := clip_i32(j, topStartL, bottomEndL-1);
	        refPos16 := ((( y - topStartL )*UP_FILTER_INF[3] + UP_FILTER_INF[1]) >> 12);
	        phase    := refPos16 & 15;
	        refPos   := refPos16 >> 4;
	        coeff    := up_sample_filter_luma[phase];
	        //coeff 	 := up_sample_filter_luma[phase];
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma[phase][k];
	        end
	        refPos   := refPos - ((NTAPS_LUMA>>1) - 1);
	        //srcY1    := tempBufY + refPos *widthEL; TODO
	        //dstY     := dstBufY + j * strideEL; TODO
	        if (refPos < 0) then
	            foreach int i in 0 .. widthEL - 1 do
	                foreach int k in 0 ..(-refPos) - 1 do
	                    buffer1[k] := srcY1[cnt_srcY1 -refPos*widthEL]; //srcY1[(-refPos+k)*strideEL];
	                end
	                foreach int k in 0 .. (8+refPos) - 1 do
	                    buffer1[-refPos+k] := srcY1[cnt_srcY1 + (-refPos+k)*widthEL];
	                end
	                dstY[cnt_dstY] := clip_i32( ((LumVer_FILTER(buffer1, coeff) + iOffset) >> (nShift)), 0, 255);
	
	                if( (i >= leftStartL) && (i <= rightEndL-2) ) then
	                    cnt_srcY1 := cnt_srcY + 1;
	                end
	                cnt_dstY := cnt_dstY + 1;
	        	end
			elsif(refPos+8 > heightBL ) then
                foreach int i in 0 .. widthEL - 1 do
                    
                    foreach int k in 0 .. (heightBL-refPos) - 1 do
                        buffer1[k] := srcY1[cnt_srcY1 + k*widthEL];
                    end
                    foreach int k in 0 .. (8-(heightBL-refPos)) - 1 do
                        buffer1[heightBL-refPos+k] := srcY1[cnt_srcY1 + (heightBL-refPos-1)*widthEL];
                    end
                    dstY[cnt_dstY] := clip_i32(( (LumVer_FILTER(buffer1, coeff) + iOffset) >> (nShift)), 0, 255);
                    
                    if( (i >= leftStartL) && (i <= rightEndL-2) ) then
                        cnt_srcY1 := cnt_srcY + 1;
                    end
                    cnt_dstY := cnt_dstY + 1;
        		end
			else
                foreach int i in 0 .. widthEL - 1 do
                	foreach int k in 0 .. 8-1 do
	                	//memcpy(buffer, srcY, 8);
	                	buffer[k] := srcY1[k*widthEL + cnt_srcY1];
	               	end
                    dstY[cnt_dstY] := clip_i32(( (LumVer_FILTER(buffer, coeff) + iOffset) >> (nShift)), 0, 255);
                    if( (i >= leftStartL) && (i <= rightEndL-2) ) then
                        cnt_srcY1 := cnt_srcY1 + 1;
                    end
                    cnt_dstY := cnt_dstY + 1;
                end
			end
	    end

	end
	
procedure upsample_base_layer_frame_Chr(uint(size=8)dstBufU[1280*2304], uint(size=8)srcBufU[1280*2304], uint(size=8) tempBufU[1280*2304],
											int widthBL, int heightBL, int strideBL, int widthEL, int heightEL, int strideEL,
											int leftStartL, int rightEndL, int topStartL, int bottomEndL,
											int leftStartC, int rightEndC, int topStartC, int bottomEndC)
	var  
//    
//	    int widthBL :=  FrameBL->coded_width,
//	    int heightBL := FrameBL->coded_height,
//	    int strideBL := FrameBL->linesize[0],
//	    int widthEL :=  FrameEL->coded_width - Enhscal->left_offset - Enhscal->right_offset,
//	    int heightEL := FrameEL->coded_height - Enhscal->top_offset - Enhscal->bottom_offset,
//	    int strideEL := FrameEL->linesize[0],
		
		uint(size=8) srcU [1280*2304],
	    uint(size=8) dstU [1280*2304],
	    uint(size=16) srcU1 [1280*2304],
	    uint(size=16) dstU1 [1280*2304],
	    
	    int refPos16 := 0,
	    int phase    := 0,
	    int refPos   := 0,
	    int(size=8) coeff[4],
//	    int leftStartL = Enhscal->left_offset,
//	    int rightEndL  = FrameEL->coded_width - Enhscal->right_offset,
//	    int topStartL  = Enhscal->top_offset,
//	    int bottomEndL = FrameEL->coded_height - Enhscal->bottom_offset,
	    uint(size=8) buffer[8],
	    int nShift = 20-8,
	    int iOffset = 1 << (nShift - 1),
	    uint(size=8) buffer1[8],
	
//	    int leftStartC = Enhscal->left_offset>>1,
//	    int rightEndC  = (FrameEL->coded_width>>1) - (Enhscal->right_offset>>1),
//	    int topStartC  = Enhscal->top_offset>>1,
//	    int bottomEndC = (FrameEL->coded_height>>1) - (Enhscal->bottom_offset>>1),
	    int x,
	    int y,
	    int cnt_dstU1 := 0,
	    int cnt_srcU1 := 0,
	    int cnt_dstU := 0,
	    int cnt_srcU := 0
	begin 
		widthEL   := widthEL >> 1;
	    heightEL  := heightEL >> 1;
	    widthBL   := widthBL >> 1;
	    heightBL  := if(heightBL > heightEL) then heightBL else heightEL end;
	    heightBL  := heightBL >> 1;

//	    
//	    widthBL   = FrameBL->coded_width;
//	    heightBL  = FrameBL->coded_height;
//	    
//	    widthEL   = FrameEL->coded_width - Enhscal->right_offset - Enhscal->left_offset;
//	    heightEL  = FrameEL->coded_height - Enhscal->top_offset - Enhscal->bottom_offset;
//	    
//	    widthEL  >>= 1;
//	    heightEL >>= 1;
//	    widthBL  >>= 1;
//	    heightBL >>= 1;
//	    strideBL  = FrameBL->linesize[1];
//	    strideEL  = FrameEL->linesize[1];
//	    widthEL   = FrameEL->coded_width >> 1;
//	    heightEL  = FrameEL->coded_height >> 1;
//	    widthBL   = FrameBL->coded_width >> 1;
//	    heightBL  = FrameBL->coded_height > heightEL ? FrameBL->coded_height:heightEL;
//	    
//	    
//	    heightBL >>= 1;
//	    
	    //========== horizontal upsampling ===========
	    /** 
 * UP_FILTER_INF
    int addXLum;	0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
	
	    foreach int i in 0 .. widthEL - 1 do
	    	x := clip_i32(i, leftStartC, rightEndC - 1);
	        refPos16 := (((x - leftStartC)*UP_FILTER_INF[6] + UP_FILTER_INF[4]) >> 12);
	        phase    := refPos16 & 15;
	        refPos   := refPos16 >> 4;
	        
	       //coeff := up_sample_filter_chroma[phase];
	        foreach int k in 0 .. 3 do
	        	coeff[k]    := up_sample_filter_chroma[phase][k];
	        end
	        refPos := refPos - ((NTAPS_CHROMA>>1) - 1);
//	        srcU = srcBufU + refPos; // -((NTAPS_CHROMA>>1) - 1); TODO
//	        dstU1 = tempBufU + i; TODO
	        
	        if(refPos < 0) then
	            foreach int j in 0 .. heightBL - 1 do
	                foreach int k in 0 .. (-refPos)-1 do
	                	//memset(buffer, srcU[-refPos], -refPos);
	                	buffer[k] := srcU[cnt_srcU -refPos];
	               	end
	        		foreach int k in 0 .. (4+refPos) - 1 do
	                	//memcpy(buffer-refPos, srcU-refPos, 4+refPos);
	                	buffer[k-refPos] := srcU[k + cnt_srcU - refPos];
	               	end	                
	                dstU1[cnt_dstU1] := CroHor_FILTER(buffer, coeff);	                
	                
	                cnt_srcU  := cnt_srcU + strideBL;
	                cnt_dstU1 := cnt_dstU1 + widthEL;
	            end
        	elsif(refPos+4 > widthBL ) then
                foreach int j in 0 .. heightBL - 1 do
                    foreach int k in 0 .. (widthBL-refPos) - 1 do
	                	//memcpy(buffer, srcU, widthBL-refPos);
	                	buffer[k] := srcU[k + cnt_srcU];
	               	end
                    foreach int k in 0 .. (4-(widthBL-refPos))-1 do
	                	//memset(buffer+(widthBL-refPos), srcU[widthBL-refPos-1], 4-(widthBL-refPos));
	                	buffer[k + (widthBL-refPos)] := srcU[cnt_srcU + widthBL - refPos - 1];
	               	end  
                    
                    dstU1[cnt_dstU1] := CroHor_FILTER(buffer, coeff);

                	cnt_srcU  := cnt_srcU + strideBL;
                    cnt_dstU1 := cnt_dstU1 + widthEL;
				end
            else
                foreach int j in 0 .. heightBL-1 do
	               	foreach int k in 0 .. 4-1 do
	                	//memcpy(buffer, srcY, 8);
	                	buffer[k] := srcU[k + cnt_srcU];
	               	end
                    dstU1[cnt_dstU1] := CroHor_FILTER(buffer, coeff);
                    cnt_srcU  := cnt_srcU + strideBL;
                    cnt_dstU1 := cnt_dstU1 + widthEL;
                end
        	end
	    end
	
	    foreach int j in 0 .. heightEL - 1 do
	        y := clip_i32(j, topStartC, bottomEndC - 1);
	        refPos16 := (((y - topStartC)*UP_FILTER_INF[7] + UP_FILTER_INF[5]) >> 12) - 4;
	     //   printf("j %d refPos16 %d phase %d refPos %d refPos %d \n", j, refPos16, phase, refPos, refPos - ((NTAPS_CHROMA>>1) - 1) );
	        phase    := refPos16 & 15;
	        refPos   := refPos16 >> 4;
	         
	        //coeff   := up_sample_filter_chroma[phase];
	         foreach int k in 0 .. 3 do
	        	coeff[k]    := up_sample_filter_chroma[phase][k];
	        end
	        refPos  := refPos - ((NTAPS_CHROMA>>1) - 1);
	        //srcU1   := tempBufU  + refPos *widthEL; TODO
	        //dstU    := dstBufU + j*strideEL; TODO
	        if (refPos < 0) then
	            foreach int i in 0 .. widthEL - 1 do
	                foreach int k in 0 .. (-refPos)-1 do
	                    buffer1[k] := srcU1[cnt_srcU1 + (-refPos)*widthEL];
	                end
	                foreach int k in 0 .. (4+refPos) - 1 do
	                    buffer1[-refPos+k] := srcU1[cnt_srcU1 + (-refPos+k)*widthEL];
	                end
	                dstU[cnt_dstU] := clip_i32(( (CroVer_FILTER(buffer1, coeff) + iOffset) >> (nShift)), 0, 255);
	                if ( (i >= leftStartC) && (i <= rightEndC-2) ) then
	                    cnt_srcU1 := cnt_srcU1 + 1;
	                end
	                cnt_dstU := cnt_dstU + 1;
            	end
            elsif (refPos+4 > heightBL) then
                foreach int i in 0 .. widthEL - 1 do
                    foreach int k in 0 .. (heightBL-refPos) - 1 do
                        buffer1[k] := srcU1[cnt_srcU1 + k*widthEL];
                    end
                    foreach int k in 0 .. (4-(heightBL-refPos))-1 do
                        buffer1[heightBL-refPos+k] := srcU1[cnt_srcU1 + (heightBL-refPos-1)*widthEL];
                    end
                    dstU[cnt_dstU] := clip_i32 (((CroVer_FILTER(buffer1, coeff) + iOffset) >> (nShift)), 0, 255);
                    if ( (i >= leftStartC) && (i <= rightEndC-2) ) then
                        cnt_srcU1 := cnt_srcU1 + 1;
                    end
                    cnt_dstU := cnt_dstU + 1;
                end
            else
	            foreach int i in 0 .. widthEL - 1 do
	               	foreach int k in 0 .. 8-1 do
	                	//memcpy(buffer, srcY, 8);
	                	buffer[k] := srcU1[k*widthEL + cnt_srcU1];
	               	end
	                dstU[cnt_dstU] := clip_i32( ((CroVer_FILTER(buffer, coeff) + iOffset) >> (nShift)), 0, 255);
	                if ( (i >= leftStartC) && (i <= rightEndC-2) ) then
	                    cnt_srcU1 := cnt_srcU1 + 1;
	                end
	                cnt_dstU := cnt_dstU + 1;
	            end
			end
		end
	end
	
	
end