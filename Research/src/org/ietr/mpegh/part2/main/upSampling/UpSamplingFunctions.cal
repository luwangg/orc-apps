package org.ietr.mpegh.part2.main.upSampling;
import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

unit UpSamplingFunctions :
	
	int N_SHIFT  				= 20-8;
	int I_OFFSET 				= (1 << (N_SHIFT - 1));
	int MAX_EDGE_CR 			= 2;
	int MAX_EDGE				= 4;
	int SNR						= 3;
	int MAX_PB_SIZE				= 64;						
	int MAX_EDGE_BUFFER_STRIDE	= ((MAX_PB_SIZE+20) * 2);
	int MAX_EDGE_BUFFER_SIZE	= ((MAX_PB_SIZE + 20) * (MAX_PB_SIZE+20) * 2);
	
	int(size=8) up_sample_filter_chroma[16][4]=
	[
    [  0,  64,   0,  0],
    [ -2,  62,   4,  0],
    [ -2,  58,  10, -2],
    [ -4,  56,  14, -2],
    [ -4,  54,  16, -2],
    [ -6,  52,  20, -2],
    [ -6,  46,  28, -4],
    [ -4,  42,  30, -4],
    [ -4,  36,  36, -4],
    [ -4,  30,  42, -4],
    [ -4,  28,  46, -6],
    [ -2,  20,  52, -6],
    [ -2,  16,  54, -4],
    [ -2,  14,  56, -4],
    [ -2,  10,  58, -2],
    [  0,   4,  62, -2]
	];

	int(size=8) up_sample_filter_luma[16][8]=
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [  0,  1,  -3,  63,   4,  -2,  1,  0],
    [ -1,  2,  -5,  62,   8,  -3,  1,  0],
    [ -1,  3,  -8,  60,  13,  -4,  1,  0],
    [ -1,  4, -10,  58,  17,  -5,  1,  0],
    [ -1,  4, -11,  52,  26,  -8,  3, -1],
    [ -1,  3,  -9,  47,  31, -10,  4, -1],
    [ -1,  4, -11,  45,  34, -10,  4, -1],
    [ -1,  4, -11,  40,  40, -11,  4, -1],
    [ -1,  4, -10,  34,  45, -11,  4, -1],
    [ -1,  4, -10,  31,  47,  -9,  3, -1],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [  0,  1,  -5,  17,  58, -10,  4, -1],
    [  0,  1,  -4,  13,  60,  -8,  3, -1],
    [  0,  1,  -3,   8,  62,  -5,  2, -1],
    [  0,  1,  -2,   4,  63,  -3,  1,  0]
	];

	int(size=8) up_sample_filter_luma_x2[2][8] = /*0 , 8 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  4, -11,  40,  40, -11,  4, -1]
	];

	int(size=8) up_sample_filter_luma_x1_5[3][8] = /* 0, 11, 5 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [ -1,  4, -11,  52,  26,  -8,  3, -1]
	];

	int(size=8) up_sample_filter_chroma_x1_5[3][4]= /* 0, 11, 5 */
	[
    [  0,  64,   0,  0],
    [ -2,  20,  52, -6],
    [ -6,  52,  20, -2]
	];
	int(size=8) up_sample_filter_x1_5chroma[3][4]=
	[
    [  0,   4,  62, -2],
    [ -4,  30,  42, -4],
    [ -4,  54,  16, -2]
	];

	int(size=8) up_sample_filter_chroma_x2[2][4]=
	[
    [  0,  64,   0,  0],
    [ -4,  36,  36, -4]
	];

	int(size=8) up_sample_filter_chroma_x2_v[2][4]=
	[
    [ -2,  10,  58, -2],
    [ -6,  46,  28, -4]
	];

	function LumVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	function CroVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[4], int widthEL) --> int(size=16) :
		(pel[0]*coeff[0] + pel[widthEL]*coeff[1] + pel[widthEL*2]*coeff[2] + pel[widthEL*3]*coeff[3])
	end
	
	function LumVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width) --> int(size=16) :
		(pel[0]*coeff[0] + pel[width]*coeff[1] + pel[width*2]*coeff[2] + pel[width*3]*coeff[3] + pel[width*4]*coeff[4] + pel[width*5]*coeff[5] + pel[width*6]*coeff[6] + pel[width*7]*coeff[7])
	end
	
	function LumHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int offset) --> int(size=16) :
		(pel[-3 + offset]*coeff[0] + pel[-2 + offset]*coeff[1] + pel[-1 + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[1 + offset]*coeff[4] + pel[2 + offset]*coeff[5] + pel[3 + offset]*coeff[6] + pel[4 + offset]*coeff[7])
	end
	
	function CroHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int offset) --> int(size=16) :
		(pel[-1 + offset]*coeff[0] + pel[0 + offset]*coeff[1] + pel[1 + offset]*coeff[2] + pel[2 + offset]*coeff[3])
	end
	
	function LumVer_FILTER_Block(uint(size=8) pel [MAX_EDGE_BUFFER_SIZE], uint (size=8) coeff[8], int width, int offset) --> int(size=16) :
		(pel[-3*width + offset]*coeff[0] + pel[-2*width + offset]*coeff[1] + pel[-width + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[width + offset]*coeff[4] + pel[2*width + offset]*coeff[5] + pel[3*width + offset]*coeff[6] + pel[4*width + offset]*coeff[7])
	end
	
	function CroVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int width, int offset) --> int(size=16) :
		(pel[-width]*coeff[0] + pel[0]*coeff[1] + pel[width]*coeff[2] + pel[2*width]*coeff[3])
	end
	
	function LumHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	procedure emulated_edge_up_h (uint(size=8) src[39*32], int linesize,
                                    int Enhscal[4],
                                    int block_w, int block_h, int bl_edge_left, int bl_edge_right, int shift)
  	begin
	    if(bl_edge_left < shift) then
	        foreach int i in 0 .. block_h - 1 do
	        	foreach int j in 0 .. shift - 1 do
	            	src[j + i * linesize] := src[shift + i * linesize];
	            end
	        end
	    end
	    
	    if(bl_edge_right<(shift+1)) then
	        foreach int i in 0 .. block_h - 1 do
	        	foreach int j in 0 .. shift do
	            	src[block_w + shift + j + i * linesize] := src[block_w -1 + shift + i * linesize]; // linesize = 39
	            end
	        end
	    end
	end
	
	procedure emulated_edge_up_v(int(size=16) src[MAX_EDGE_BUFFER_SIZE], int linesize, int Enhscal[4], int block_w, 
								 int block_h, int src_x, int bl_edge_up, int bl_edge_bottom, int wEL, int shift)
	var
	    int rightEndL  := wEL - (Enhscal[1] >> (if(shift=(MAX_EDGE_CR-1)) then 1 else 0 end)),
	    int leftStartL := (Enhscal[0]>> (if shift=(MAX_EDGE_CR-1) then 1 else 0 end)),
	    int src_offset := shift * linesize,
	    int dst_offset := shift * linesize  
    begin
	    if(bl_edge_up < shift)  then
	        foreach int i in 0 .. block_w - 1 do
	            foreach int j in bl_edge_up .. shift - 1 do
	                src[(-j-1)*linesize + dst_offset] := src[-bl_edge_up*linesize + src_offset];
	            end   
	            if( ((src_x+i) >= leftStartL) && ((src_x+i) <= rightEndL-2) ) then
	                src_offset := src_offset + 1;
	            end
	            dst_offset := dst_offset + 1;
	        end
	    
	    elsif(bl_edge_bottom < (shift+1) )    then
	        foreach int i in 0 .. block_w - 1 do
	            foreach int j in 0 .. shift+1 - 1 do
	                src[(block_h+j)*linesize + dst_offset] := src[(block_h-1)*linesize + src_offset];
	            end
	            if( ((src_x+i) >= leftStartL) && ((src_x+i) <= rightEndL-2) ) then
	                src_offset := src_offset + 1;
	            end
	            dst_offset := dst_offset + 1;
	        end
	    end
	end

/*up_info{
 * int addXLum;		0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
 /* 
 	Enhscal {
	    int left_offset;	0
	    int right_offset;	1
	    int top_offset;		2
	    int bottom_offset;	3
	} HEVCWindow;
	* */

	procedure upsample_filter_block_luma_h_x2( int(size=16) dst[MAX_EDGE_BUFFER_SIZE], int _dststride, uint(size=8) src[39*32], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int x,
	    int(size=8) coeff[8],
	    int offset := 0
	begin
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma_x2[x&0x01][k];
	        end
	        offset := ((x-leftStartL)>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	            dst[i + j * _dststride] := LumHor_FILTER_Block(src, coeff, offset+3);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_h_x2 ( int(size=16) dst[32*16], int _dststride, uint(size=8) src[19*16], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int x,
	    int(size=8) coeff[4],
	    int offset := 0
	begin 
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartC, rightEndC);
	        foreach int k in 0 .. 3 do
	        	coeff[k]    := up_sample_filter_chroma_x2[x&0x01][k];
	        end
	        offset := (x>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	        	dst[i + j * _dststride] := CroHor_FILTER_Block(src, coeff, offset+1);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_luma_v_x2( uint(size=8) dst[64*64], int _dststride, int(size=16) src[MAX_EDGE_BUFFER_SIZE], int _srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
    var
	    int topStartL  := Enhscal[2],
	    int bottomEndL := heightEL - Enhscal[3],
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int y,
	    int(size=8) coeff[8],
    	int offset := 0
	begin
	    foreach int j in 0 .. block_h - 1 do
	    	y        := clip_i32(y_EL+j, topStartL, bottomEndL-1);
	        foreach int k in 0 .. 3 do
	        	coeff[k] := up_sample_filter_luma_x2[(y-topStartL)&0x01][k];
	        end	
	        offset  := (((y-topStartL)>>1)-y_BL)  * _srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[j*_dststride + i] := clip_i32( (LumVer_FILTER_Block(src, coeff, _srcstride, offset + 3 * _srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartL) && ((x_EL+i) <= rightEndL-2) ) then
	                offset := offset + 1;
	            end   
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_v_x2 (uint(size=8) dst[32*32], int dststride, int(size=16) src[32*19], int srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
	var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int topStartC  := Enhscal[2]>>1,
	    int bottomEndC := heightEL - (Enhscal[3]>>1),
	    int y,
	    int refPos16, 
	    int refPos,
	    int(size=8) coeff[4],
	    int offset := 0
	begin
	    foreach int j in 0 .. block_h -1 do
	        y        :=   clip_i32(y_EL+j, topStartC, bottomEndC-1);
	        refPos16 := ((( y - topStartC )* up_info[7] + up_info[5]) >> 12) - 4;
	        coeff    := up_sample_filter_chroma_x2_v[y&0x01];
	        refPos   := (refPos16>>4) - y_BL;
	        offset   := refPos  * srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[i + y* dststride + x_EL] := clip_i32( (CroVer_FILTER_Block(src, coeff, srcstride, offset + srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartC) && ((x_EL+i) <= rightEndC-2) ) then
	                offset := offset + 1; 
	            end
	        end
	    end
	end
	
	procedure upscale_mv_block (int(size=16) mv_dst [17][PICT_WIDTH/4][PICT_HEIGHT/4][2][2],int(size=16) mv_src [17][PICT_WIDTH/4][PICT_HEIGHT/4][2][2],
								int dst_pred_flag[17][PICT_WIDTH/4][PICT_HEIGHT/4],int src_pred_flag[17][PICT_WIDTH/4][PICT_HEIGHT/4], 
								int(size=4) refIdxRef[17][PICT_WIDTH/4][PICT_HEIGHT/4][2], /*TODO: add poc table, !!*/ int currentFrame,
								int ctb_x, int ctb_y, int sps_width, int sps_height, int log2_min_pu_size, int bl_width, int bl_height, int log2_ctb_size,
								 int sliceType, int sps_pic_conf_win_left_offset, int sps_pic_conf_win_top_offset,int up_info[9]
								) 
	var
	    int xEL := ctb_x,
	    int yEL := ctb_y,
	    int xBL, 
	    int yBL, 
	    int Ref_pre_unit, 
	    int pre_unit, 
	    int pre_unit_col,
	    int pic_width_in_min_pu   = sps_width  >> log2_min_pu_size,
	    int pic_height_in_min_pu  = sps_height >> log2_min_pu_size,
	    int pic_width_in_min_puBL = bl_width   >> log2_min_pu_size,
	    int ctb_size = 1 << log2_ctb_size,
	    int nb_list = if (sliceType=B_SLICE) then 2 else 1 end
	    //HEVCFrame *refBL = s->BL_frame;
	    //HEVCFrame *refEL = s->inter_layer_ref;
	begin
	    while (yEL < ctb_y+ctb_size && yEL<sps_height) do
	        while(xEL < ctb_x+ctb_size && xEL<sps_width) do
	            xBL := (((clip_i32(xEL+8, 0, sps_width -1)  - sps_pic_conf_win_left_offset)* up_info[2] + (1<<15)) >> 16) + 4;
	            yBL := (((clip_i32(yEL+8, 0, sps_height -1) - sps_pic_conf_win_top_offset )*up_info[3] + (1<<15)) >> 16) + 4;
	            pre_unit := ((yEL>>log2_min_pu_size)*pic_width_in_min_pu) + (xEL>>log2_min_pu_size);
	            if(xBL < bl_width && yBL < bl_height) then
	                xBL := xBL >> 4;
	                xBL := xBL << (4-log2_min_pu_size); // 4 <==> xBL & 0xFFFFFFF0
	                yBL := yBL >> 4;
	                yBL := yBL << (4-log2_min_pu_size); // 4 <==> yBL & 0xFFFFFFF0
	                Ref_pre_unit := (yBL*pic_width_in_min_puBL)+xBL;
	                if src_pred_flag[currentFrame][xBL][yBL] != 0 then
	                    if (up_info[8] = SNR) then
	                        //memcpy(&refEL->tab_mvf[pre_unit], &refBL->tab_mvf[Ref_pre_unit], sizeof(MvField));
	                        // TODO: copy 4 elements on MVField
	                    else
	
	                        foreach int list in 0 .. nb_list - 1 do
//	                            refEL->tab_mvf[pre_unit].mv[list].x := clip_i32( (s->sh.ScalingFactor[s->nuh_layer_id][0] * refBL->tab_mvf[Ref_pre_unit].mv[list].x + 127 + (s->sh.ScalingFactor[s->nuh_layer_id][0] * refBL->tab_mvf[Ref_pre_unit].mv[list].x < 0)) >> 8 , -32768, 32767);
//	                            refEL->tab_mvf[pre_unit].mv[list].y := clip_i32( (s->sh.ScalingFactor[s->nuh_layer_id][1] * refBL->tab_mvf[Ref_pre_unit].mv[list].y + 127 + (s->sh.ScalingFactor[s->nuh_layer_id][1] * refBL->tab_mvf[Ref_pre_unit].mv[list].y < 0)) >> 8, -32768, 32767);
//	                            refEL->tab_mvf[pre_unit].ref_idx[list] = refBL->tab_mvf[Ref_pre_unit].ref_idx[list];
//	                            refEL->tab_mvf[pre_unit].poc[list] = refBL->tab_mvf[Ref_pre_unit].poc[list];
//	                            refEL->tab_mvf[pre_unit].pred_flag = refBL->tab_mvf[Ref_pre_unit].pred_flag;
	                        end
	                    end
	                else
	                    //memset(&refEL->tab_mvf[pre_unit], 0, sizeof(MvField));
					end
	
	            else
	                //memset(&refEL->tab_mvf[pre_unit], 0, sizeof(MvField));
	            end
	
	            if( ((xEL+1)>>log2_min_pu_size) < pic_width_in_min_pu && ((yEL+1)>>log2_min_pu_size) < pic_height_in_min_pu) then
	                pre_unit_col := (((yEL+1)>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL+1)>>log2_min_pu_size);
//	                memcpy(&refEL->tab_mvf[pre_unit_col], &refEL->tab_mvf[pre_unit], sizeof(MvField));
	            end
	            if( ((xEL+1)>>log2_min_pu_size) < pic_width_in_min_pu) then
	                pre_unit_col := ((yEL>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL+1)>>log2_min_pu_size);
//	                memcpy(&refEL->tab_mvf[pre_unit_col], &refEL->tab_mvf[pre_unit], sizeof(MvField));
	            end
	            if( ((yEL+1)>>log2_min_pu_size) < pic_height_in_min_pu) then
	                pre_unit_col := (((yEL+1)>>log2_min_pu_size)*pic_width_in_min_pu) + ((xEL)>>log2_min_pu_size);
//	                memcpy(&refEL->tab_mvf[pre_unit_col], &refEL->tab_mvf[pre_unit], sizeof(MvField));
	            end
	        	xEL :=xEL + 16;
	        end
	    	yEL := yEL + 16;
	    end
	end
	
end