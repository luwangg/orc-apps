package org.ietr.mpegh.part2.main.upSampling;
import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

unit UpSamplingFunctions :

	int(size=8) up_sample_filter_chroma[16][4]=
	[
    [  0,  64,   0,  0],
    [ -2,  62,   4,  0],
    [ -2,  58,  10, -2],
    [ -4,  56,  14, -2],
    [ -4,  54,  16, -2],
    [ -6,  52,  20, -2],
    [ -6,  46,  28, -4],
    [ -4,  42,  30, -4],
    [ -4,  36,  36, -4],
    [ -4,  30,  42, -4],
    [ -4,  28,  46, -6],
    [ -2,  20,  52, -6],
    [ -2,  16,  54, -4],
    [ -2,  14,  56, -4],
    [ -2,  10,  58, -2],
    [  0,   4,  62, -2]
	];

	int(size=8) up_sample_filter_luma[16][8]=
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [  0,  1,  -3,  63,   4,  -2,  1,  0],
    [ -1,  2,  -5,  62,   8,  -3,  1,  0],
    [ -1,  3,  -8,  60,  13,  -4,  1,  0],
    [ -1,  4, -10,  58,  17,  -5,  1,  0],
    [ -1,  4, -11,  52,  26,  -8,  3, -1],
    [ -1,  3,  -9,  47,  31, -10,  4, -1],
    [ -1,  4, -11,  45,  34, -10,  4, -1],
    [ -1,  4, -11,  40,  40, -11,  4, -1],
    [ -1,  4, -10,  34,  45, -11,  4, -1],
    [ -1,  4, -10,  31,  47,  -9,  3, -1],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [  0,  1,  -5,  17,  58, -10,  4, -1],
    [  0,  1,  -4,  13,  60,  -8,  3, -1],
    [  0,  1,  -3,   8,  62,  -5,  2, -1],
    [  0,  1,  -2,   4,  63,  -3,  1,  0]
	];

	int(size=8) up_sample_filter_luma_x2[2][8] = /*0 , 8 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  4, -11,  40,  40, -11,  4, -1]
	];

	int(size=8) up_sample_filter_luma_x1_5[3][8] = /* 0, 11, 5 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [ -1,  4, -11,  52,  26,  -8,  3, -1]
	];

	int(size=8) up_sample_filter_chroma_x1_5[3][4]= /* 0, 11, 5 */
	[
    [  0,  64,   0,  0],
    [ -2,  20,  52, -6],
    [ -6,  52,  20, -2]
	];
	int(size=8) up_sample_filter_x1_5chroma[3][4]=
	[
    [  0,   4,  62, -2],
    [ -4,  30,  42, -4],
    [ -4,  54,  16, -2]
	];

	int(size=8) up_sample_filter_chroma_x2[2][4]=
	[
    [  0,  64,   0,  0],
    [ -4,  36,  36, -4]
	];

	int(size=8) up_sample_filter_chroma_x2_v[2][4]=
	[
    [ -2,  10,  58, -2],
    [ -6,  46,  28, -4]
	];

	function LumVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	function CroVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[4], int widthEL) --> int(size=16) :
		(pel[0]*coeff[0] + pel[widthEL]*coeff[1] + pel[widthEL*2]*coeff[2] + pel[widthEL*3]*coeff[3])
	end
	
	function LumVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width) --> int(size=16) :
		(pel[0]*coeff[0] + pel[width]*coeff[1] + pel[width*2]*coeff[2] + pel[width*3]*coeff[3] + pel[width*4]*coeff[4] + pel[width*5]*coeff[5] + pel[width*6]*coeff[6] + pel[width*7]*coeff[7])
	end
	
	function LumHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int offset) --> int(size=16) :
		(pel[-3 + offset]*coeff[0] + pel[-2 + offset]*coeff[1] + pel[-1 + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[1 + offset]*coeff[4] + pel[2 + offset]*coeff[5] + pel[3 + offset]*coeff[6] + pel[4 + offset]*coeff[7])
	end
	
	function CroHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[-1]*coeff[0] + pel[0]*coeff[1] + pel[1]*coeff[2] + pel[2]*coeff[3])
	end
	
	function LumVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width) --> int(size=16) :
		(pel[-3*width]*coeff[0] + pel[-2*width]*coeff[1] + pel[-width]*coeff[2] + pel[0]*coeff[3] + pel[width]*coeff[4] + pel[2*width]*coeff[5] + pel[3*width]*coeff[6] + pel[4*width]*coeff[7])
	end
	
	function CroVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int width) --> int(size=16) :
		(pel[-width]*coeff[0] + pel[0]*coeff[1] + pel[width]*coeff[2] + pel[2*width]*coeff[3])
	end
	
	function LumHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	procedure emulated_edge_up_h (uint(size=8) src[39*39], int linesize,
                                    int Enhscal[4],
                                    int block_w, int block_h, int bl_edge_left, int bl_edge_right, int shift)
    var
	    uint(size=8) src_tmp[39*39]
	begin
	    foreach int i in 0 .. (39*39) - 1 do
	    	src_tmp[i] := src[i];
	    end
	    
	    if(bl_edge_left < shift) then
	        foreach int i in 0 .. block_h - 1 do
//	            memset(src_tmp-(shift), src_tmp[0], shift);
//	            src_tmp += linesize;
	        end
	    end
	    
	    if(bl_edge_right<(shift+1)) then
	        foreach int i in 0 .. block_h - 1 do
//	            memset(src_tmp+block_w, src_tmp[block_w-1], shift+1);
//	            src_tmp += linesize;
	        end
	    end
	end
	
//	procedure upsample_filter_block_luma_h_all( int(size=16) dst[64*64], int _dststride, uint(size=8) src, int _srcstride,
//                                        int x_EL, int x_BL, int block_w, int block_h, int widthEL,
//                                        int enhscal[4], int up_info[9]/*, int y_BL, short * buffer_frame*/)
//    var
//	    int rightEndL  = widthEL - enhscal[1],
//	    int leftStartL = enhscal[0],
//	    int x := 0,
//	    int phase := 0, 
//	    int refPos16 := 0, 
//	    int refPos := 0,
//	    int(size=16) dst_tmp[64*64], //FIXME: check size
//	    //pixel*   src_tmp,
//	    //pixel*   *src = (pixel *) _src,
//	    int(size=8) coeff[64*64] // FIXME: check size
//    begin
//	    foreach int i in 0 .. block_w - 1 do
//	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
//	        refPos16 := (((x - leftStartL)*up_info[2] +up_info[0]) >> 12);
//	        phase    := refPos16 & 15;
//	        //coeff    := 0; //FIXME: up_sample_filter_luma[phase];
//	        refPos   := (refPos16 >> 4) - x_BL;
//	        //dst_tmp  := _dst  + i;//FIXME:
//	        //src_tmp  := src   + refPos;//FIXME:
//	        foreach int j in 0 .. block_h - 1 do
//	            //*dst_tmp  := LumHor_FILTER_Block(src_tmp, coeff);
//	            //src_tmp  := src_tmp + _srcstride; //FIXME
//	            //dst_tmp  := dst_tmp + _dststride; //FIXME
//	        end
//	    end
//	end

/*up_info{
 * int addXLum;		0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
 /* 
 	Enhscal {
	    int left_offset;	0
	    int right_offset;	1
	    int top_offset;		2
	    int bottom_offset;	3
	} HEVCWindow;
	* */

	procedure upsample_filter_block_luma_h_x2( int(size=16) dst[64*32], int _dststride, uint(size=8) src[39*32], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int x,
	    int(size=8) coeff[8],
	    int offset := 0
	begin
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma_x2[x&0x01][k];
	        end
	        offset := offset + ((x-leftStartL)>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	            dst[i + j * _dststride] := LumHor_FILTER_Block(src, coeff, offset+3);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
end