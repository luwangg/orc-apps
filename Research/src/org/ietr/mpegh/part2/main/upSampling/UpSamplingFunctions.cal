package org.ietr.mpegh.part2.main.upSampling;
import std.util.Math.*;
import org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

unit UpSamplingFunctions :
	
	int N_SHIFT  = 20-8;
	int I_OFFSET = (1 << (N_SHIFT - 1));
	
	int(size=8) up_sample_filter_chroma[16][4]=
	[
    [  0,  64,   0,  0],
    [ -2,  62,   4,  0],
    [ -2,  58,  10, -2],
    [ -4,  56,  14, -2],
    [ -4,  54,  16, -2],
    [ -6,  52,  20, -2],
    [ -6,  46,  28, -4],
    [ -4,  42,  30, -4],
    [ -4,  36,  36, -4],
    [ -4,  30,  42, -4],
    [ -4,  28,  46, -6],
    [ -2,  20,  52, -6],
    [ -2,  16,  54, -4],
    [ -2,  14,  56, -4],
    [ -2,  10,  58, -2],
    [  0,   4,  62, -2]
	];

	int(size=8) up_sample_filter_luma[16][8]=
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [  0,  1,  -3,  63,   4,  -2,  1,  0],
    [ -1,  2,  -5,  62,   8,  -3,  1,  0],
    [ -1,  3,  -8,  60,  13,  -4,  1,  0],
    [ -1,  4, -10,  58,  17,  -5,  1,  0],
    [ -1,  4, -11,  52,  26,  -8,  3, -1],
    [ -1,  3,  -9,  47,  31, -10,  4, -1],
    [ -1,  4, -11,  45,  34, -10,  4, -1],
    [ -1,  4, -11,  40,  40, -11,  4, -1],
    [ -1,  4, -10,  34,  45, -11,  4, -1],
    [ -1,  4, -10,  31,  47,  -9,  3, -1],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [  0,  1,  -5,  17,  58, -10,  4, -1],
    [  0,  1,  -4,  13,  60,  -8,  3, -1],
    [  0,  1,  -3,   8,  62,  -5,  2, -1],
    [  0,  1,  -2,   4,  63,  -3,  1,  0]
	];

	int(size=8) up_sample_filter_luma_x2[2][8] = /*0 , 8 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  4, -11,  40,  40, -11,  4, -1]
	];

	int(size=8) up_sample_filter_luma_x1_5[3][8] = /* 0, 11, 5 */
	[
    [  0,  0,   0,  64,   0,   0,  0,  0],
    [ -1,  3,  -8,  26,  52, -11,  4, -1],
    [ -1,  4, -11,  52,  26,  -8,  3, -1]
	];

	int(size=8) up_sample_filter_chroma_x1_5[3][4]= /* 0, 11, 5 */
	[
    [  0,  64,   0,  0],
    [ -2,  20,  52, -6],
    [ -6,  52,  20, -2]
	];
	int(size=8) up_sample_filter_x1_5chroma[3][4]=
	[
    [  0,   4,  62, -2],
    [ -4,  30,  42, -4],
    [ -4,  54,  16, -2]
	];

	int(size=8) up_sample_filter_chroma_x2[2][4]=
	[
    [  0,  64,   0,  0],
    [ -4,  36,  36, -4]
	];

	int(size=8) up_sample_filter_chroma_x2_v[2][4]=
	[
    [ -2,  10,  58, -2],
    [ -6,  46,  28, -4]
	];

	function LumVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroVer_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	function CroVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[4], int widthEL) --> int(size=16) :
		(pel[0]*coeff[0] + pel[widthEL]*coeff[1] + pel[widthEL*2]*coeff[2] + pel[widthEL*3]*coeff[3])
	end
	
	function LumVer_FILTER1(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width) --> int(size=16) :
		(pel[0]*coeff[0] + pel[width]*coeff[1] + pel[width*2]*coeff[2] + pel[width*3]*coeff[3] + pel[width*4]*coeff[4] + pel[width*5]*coeff[5] + pel[width*6]*coeff[6] + pel[width*7]*coeff[7])
	end
	
	function LumHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int offset) --> int(size=16) :
		(pel[-3 + offset]*coeff[0] + pel[-2 + offset]*coeff[1] + pel[-1 + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[1 + offset]*coeff[4] + pel[2 + offset]*coeff[5] + pel[3 + offset]*coeff[6] + pel[4 + offset]*coeff[7])
	end
	
	function CroHor_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int offset) --> int(size=16) :
		(pel[-1 + offset]*coeff[0] + pel[0 + offset]*coeff[1] + pel[1 + offset]*coeff[2] + pel[2 + offset]*coeff[3])
	end
	
	function LumVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[8], int width, int offset) --> int(size=16) :
		(pel[-3*width + offset]*coeff[0] + pel[-2*width + offset]*coeff[1] + pel[-width + offset]*coeff[2] + pel[0 + offset]*coeff[3] + pel[width + offset]*coeff[4] + pel[2*width + offset]*coeff[5] + pel[3*width + offset]*coeff[6] + pel[4*width + offset]*coeff[7])
	end
	
	function CroVer_FILTER_Block(uint(size=8) pel [64*64], uint (size=8) coeff[4], int width, int offset) --> int(size=16) :
		(pel[-width]*coeff[0] + pel[0]*coeff[1] + pel[width]*coeff[2] + pel[2*width]*coeff[3])
	end
	
	function LumHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[8]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3] + pel[4]*coeff[4] + pel[5]*coeff[5] + pel[6]*coeff[6] + pel[7]*coeff[7])
	end
	
	function CroHor_FILTER(uint(size=8) pel [64*64], uint (size=8) coeff[4]) --> int(size=16) :
		(pel[0]*coeff[0] + pel[1]*coeff[1] + pel[2]*coeff[2] + pel[3]*coeff[3])
	end
	
	procedure emulated_edge_up_h (uint(size=8) src[39*39], int linesize,
                                    int Enhscal[4],
                                    int block_w, int block_h, int bl_edge_left, int bl_edge_right, int shift)
    var
	    uint(size=8) src_tmp[39*39]
	begin
	    foreach int i in 0 .. (39*39) - 1 do
	    	src_tmp[i] := src[i];
	    end
	    
	    if(bl_edge_left < shift) then
	        foreach int i in 0 .. block_h - 1 do
//	            memset(src_tmp-(shift), src_tmp[0], shift);
//	            src_tmp += linesize;
	        end
	    end
	    
	    if(bl_edge_right<(shift+1)) then
	        foreach int i in 0 .. block_h - 1 do
//	            memset(src_tmp+block_w, src_tmp[block_w-1], shift+1);
//	            src_tmp += linesize;
	        end
	    end
	end
	
//	procedure upsample_filter_block_luma_h_all( int(size=16) dst[64*64], int _dststride, uint(size=8) src, int _srcstride,
//                                        int x_EL, int x_BL, int block_w, int block_h, int widthEL,
//                                        int enhscal[4], int up_info[9]/*, int y_BL, short * buffer_frame*/)
//    var
//	    int rightEndL  = widthEL - enhscal[1],
//	    int leftStartL = enhscal[0],
//	    int x := 0,
//	    int phase := 0, 
//	    int refPos16 := 0, 
//	    int refPos := 0,
//	    int(size=16) dst_tmp[64*64], //FIXME: check size
//	    //pixel*   src_tmp,
//	    //pixel*   *src = (pixel *) _src,
//	    int(size=8) coeff[64*64] // FIXME: check size
//    begin
//	    foreach int i in 0 .. block_w - 1 do
//	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
//	        refPos16 := (((x - leftStartL)*up_info[2] +up_info[0]) >> 12);
//	        phase    := refPos16 & 15;
//	        //coeff    := 0; //FIXME: up_sample_filter_luma[phase];
//	        refPos   := (refPos16 >> 4) - x_BL;
//	        //dst_tmp  := _dst  + i;//FIXME:
//	        //src_tmp  := src   + refPos;//FIXME:
//	        foreach int j in 0 .. block_h - 1 do
//	            //*dst_tmp  := LumHor_FILTER_Block(src_tmp, coeff);
//	            //src_tmp  := src_tmp + _srcstride; //FIXME
//	            //dst_tmp  := dst_tmp + _dststride; //FIXME
//	        end
//	    end
//	end

/*up_info{
 * int addXLum;		0
    int addYLum;	1
    int scaleXLum;	2
    int scaleYLum;	3
    int addXCr;		4
    int addYCr;		5
    int scaleXCr;	6
    int scaleYCr;	7
    int idx;		8}
 */
 /* 
 	Enhscal {
	    int left_offset;	0
	    int right_offset;	1
	    int top_offset;		2
	    int bottom_offset;	3
	} HEVCWindow;
	* */

	procedure upsample_filter_block_luma_h_x2( int(size=16) dst[64*32], int _dststride, uint(size=8) src[39*32], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int x,
	    int(size=8) coeff[8],
	    int offset := 0
	begin
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartL, rightEndL);
	        foreach int k in 0 .. 7 do
	        	coeff[k]    := up_sample_filter_luma_x2[x&0x01][k];
	        end
	        offset := ((x-leftStartL)>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	            dst[i + j * _dststride] := LumHor_FILTER_Block(src, coeff, offset+3);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_h_x2 ( int(size=16) dst[32*16], int _dststride, uint(size=8) src[19*16], int _srcstride,
                                                  int x_EL, int x_BL, int block_w, int block_h, int widthEL,
                                                  int Enhscal[4], int up_info[9]) 
    var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int x,
	    int(size=8) coeff[4],
	    int offset := 0
	begin 
	    foreach int i in 0 .. block_w - 1 do
	        x        := clip_i32(i+x_EL, leftStartC, rightEndC);
	        foreach int k in 0 .. 3 do
	        	coeff[k]    := up_sample_filter_chroma_x2[x&0x01][k];
	        end
	        offset := (x>>1); // FIXME: to be checked
	        foreach int j in 0 .. block_h - 1 do
	        	dst[i + j * _dststride] := CroHor_FILTER_Block(src, coeff, offset+1);
	            offset := offset + j * _srcstride;
	        end
	    end
	end
	
	procedure upsample_filter_block_luma_v_x2( uint(size=8) dst[64*64], int _dststride, int(size=16) src[64*39], int _srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
    var
	    int topStartL  := Enhscal[2],
	    int bottomEndL := heightEL - Enhscal[3],
	    int rightEndL  := widthEL - Enhscal[1],
	    int leftStartL := Enhscal[0],
	    int y,
	    int(size=8) coeff[8],
    	int offset := 0
	begin
	    foreach int j in 0 .. block_h - 1 do
	    	y        := clip_i32(y_EL+j, topStartL, bottomEndL-1);
	        foreach int k in 0 .. 3 do
	        	coeff[k] := up_sample_filter_luma_x2[(y-topStartL)&0x01][k];
	        end	
	        offset  := (((y-topStartL)>>1)-y_BL)  * _srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[j*_dststride + i] := clip_i32( (LumVer_FILTER_Block(src, coeff, _srcstride, offset + 3 * _srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartL) && ((x_EL+i) <= rightEndL-2) ) then
	                offset := offset + 1;
	            end   
	        end
	    end
	end
	
	procedure upsample_filter_block_cr_v_x2 (uint(size=8) dst[32*32], int dststride, int(size=16) src[32*19], int srcstride,
                                                  int y_BL, int x_EL, int y_EL, int block_w, int block_h, int widthEL, int heightEL,
                                                  int Enhscal[4], int up_info[9])
	var
	    int leftStartC := Enhscal[0]>>1,
	    int rightEndC  := widthEL - (Enhscal[1]>>1),
	    int topStartC  := Enhscal[2]>>1,
	    int bottomEndC := heightEL - (Enhscal[3]>>1),
	    int y,
	    int refPos16, 
	    int refPos,
	    int(size=8) coeff[4],
	    int offset := 0
	    //int16_t *   src_tmp;
	    //pixel *dst_tmp, *dst    = (pixel *)_dst;
	begin
	    foreach int j in 0 .. block_h -1 do
	        y        :=   clip_i32(y_EL+j, topStartC, bottomEndC-1);
	        refPos16 := ((( y - topStartC )* up_info[7] + up_info[5]) >> 12) - 4;
	        coeff    := up_sample_filter_chroma_x2_v[y&0x01];
	        refPos   := (refPos16>>4) - y_BL;
	        offset   := refPos  * srcstride;
	        foreach int i in 0 .. block_w - 1 do
	            dst[i + y* dststride + x_EL] := clip_i32( (CroVer_FILTER_Block(src, coeff, srcstride, offset + srcstride) + I_OFFSET) >> (N_SHIFT), 0, 255);
	            if( ((x_EL+i) >= leftStartC) && ((x_EL+i) <= rightEndC-2) ) then
	                offset := offset + 1; 
	            end
	        end
	    end
	end
	
end