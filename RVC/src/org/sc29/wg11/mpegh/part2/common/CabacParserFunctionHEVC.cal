/********************************************************************************

This software module was originally developed by 
Gildas Cocherel and khaled JERBI (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2014.
 

*****************************************************************************/
/******************************************************************************
 * Definition of CabacContextFunction
 *****************************************************************************/
package org.sc29.wg11.mpegh.part2.common;

import  std.util.Math.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  org.sc29.wg11.common.CabacDebinarizationFunction.*;

import  org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacContextConstantHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacContextTableHEVC.*;
import  org.sc29.wg11.mpegh.part2.common.CabacContextFunctionHEVC.*;

unit CabacParserFunctionHEVC :

    /*************************************************************************
     * decodeBypassTop
     *************************************************************************/
    procedure decodeBypassTop(
        uint(size=32) binString[1],
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
    )
    var
        uint(size= 1) binVal[1]
    begin
        decodeBypass(codIRange, codIOffset, binVal, fifo);           
        binString[0] := binVal[0];
        if DEBUG_CABAC then
            //println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);
        end       
    end
    /*************************************************************************
     * decodeDecisionTop
     *************************************************************************/
    procedure decodeDecisionTop(
        uint(size= 9) ctxIdx,
        uint(size=32) binString[1],
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size= 8) se,
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
    )
    var
        uint(size=7) state[1]    := [0],
        uint(size=1) mps[1]     := [0],
        uint(size=1) binVal[1]    := [0]
    begin
        state[0]  := ctxTable[se][ctxIdx] >> 1;
        mps[0]    := ctxTable[se][ctxIdx]  & 1;
        if DEBUG_CABAC then
            //println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]);
        end       
        decodeDecision(codIRange, codIOffset, state, mps, binVal, fifo);
        ctxTable[se][ctxIdx] := (state[0] << 1) + mps[0];
        if DEBUG_CABAC then
            //println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" state := "+state[0]+" mps := "+mps[0]+" binVal := "+binVal[0]);
        end       
        binString[0] := (binString[0] << 1) + binVal[0];
    end
    /*************************************************************************
     * decodeTerminateTop
     *************************************************************************/
    procedure decodeTerminateTop(
        uint(size=32) binString[1],
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
    )
    begin
        decodeTerminate(codIRange, codIOffset, binString, fifo);
        if DEBUG_CABAC then
            //println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]+" binVal := "+binString[0]);
        end       
    end
    /*************************************************************************
     * decodeBinsEP
     *************************************************************************/
    procedure decodeBinsEP(
        uint(size= 8) numBins,
        uint(size=32) binString[1],
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
    )
    var
        uint(size=32) binVal[1]
    begin
        if (numBins!=1) then
            binString[0] := 0;
            foreach int i in 0 .. numBins-1 do
                decodeBypassTop(binVal, codIRange, codIOffset, fifo);
                binString[0] := (binString[0] << 1) + binVal[0];
            end
        else
            decodeBypassTop(binString, codIRange, codIOffset, fifo);           
        end
    end
    /*************************************************************************
     * xReadEpExGolomb
     *************************************************************************/
    procedure xReadEpExGolomb(
        uint(size=32) count_int,
        uint(size=32) debinValue[1],
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL]
    )
    var
        uint(size=32) count  := count_int,
        uint(size=32) bit[1] := [1],
        uint(size=32) binString[1] := [0]
    begin
        debinValue[0] := 0;
        while bit[0] = 1 do
            decodeBypassTop(bit, codIRange, codIOffset, fifo);
            debinValue[0] := debinValue[0] + (bit[0] << count);
            count := count + 1;
        end
        count := count - 1;
        if count != 0 then
            decodeBinsEP(count, binString, codIRange, codIOffset, fifo);
            debinValue[0] := debinValue[0] + binString[0];
        end
    end
    /*************************************************************************
     * get_SAO_MERGE_FLAG
     *************************************************************************/
    procedure get_SAO_MERGE_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" SAO_MERGE_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
       
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_SAO_MERGE_FLAG, fifo);
        if DEBUG_CABAC then
        	println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
            //println(" SAO_MERGE_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SAO_TYPE_IDX
     *************************************************************************/
    procedure get_SAO_TYPE_IDX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    var
        uint(size=32) binString[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" SAO_TYPE_IDX ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
       
        decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_SAO_TYPE_IDX, fifo);
        if binString[0] = 0 then
            debinValue[0] := SAO_NOT_APPLIED;
        else
            decodeBypassTop(binString, codIRange, codIOffset, fifo);
            if binString[0] = 0 then
                debinValue[0] := SAO_BAND;
            else
                debinValue[0] := SAO_EDGE;
            end
        end
        if DEBUG_CABAC then
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
    end
    /*************************************************************************
     * get_SAO_OFFSET_ABS
     *************************************************************************/
    procedure get_SAO_OFFSET_ABS(
        uint(size= 8) offsetTh,
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    var
        uint(size= 8) binIdx := 0,
        uint(size= 1) debinCompleted[1] := [0],
        uint(size= 1) discard_suffix[1] := [0],       
        uint(size=32) binString[1]
    begin
        if DEBUG_CABAC then
            println(" SAO_OFFSET_ABS ==> "+offsetTh);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end   
        while debinCompleted[0] = 0 do
            decodeBypassTop(binString, codIRange, codIOffset, fifo);
            debinTU(binString[0], binIdx, offsetTh-1, debinCompleted, debinValue, discard_suffix);
            binIdx := binIdx + 1;
        end
        if DEBUG_CABAC then
            //println(" SAO_OFFSET_ABS = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SAO_OFFSET_SIGN
     *************************************************************************/
    procedure get_SAO_OFFSET_SIGN(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" SAO_OFFSET_SIGN ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBypassTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" SAO_OFFSET_SIGN = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SAO_BAND_POSITION
     *************************************************************************/
    procedure get_SAO_BAND_POSITION(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" SAO_BAND_POSITION ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBinsEP(5, debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" SAO_BAND_POSITION = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SAO_EO
     *************************************************************************/
    procedure get_SAO_EO(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" SAO_EO ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBinsEP(2, debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" SAO_EO = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_CU_TRANSQUANT_BYPASS_FLAG
     *************************************************************************/
    procedure get_CU_TRANSQUANT_BYPASS_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" CU_TRANSQUANT_BYPASS_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
       
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_CU_TRANSQUANT_BYPASS_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" CU_TRANSQUANT_BYPASS_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SPLIT_CODING_UNIT_FLAG
     *************************************************************************/
    procedure get_SPLIT_CODING_UNIT_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        //
        uint(size= 8) depthSubPart,
        bool          availableA,
        uint(size= 8) depthSubPartA,
        bool          availableB,
        uint(size= 8) depthSubPartB
    )
    var
        uint(size= 9) ctxIdx
    begin
        ctxIdx      := context_93311_SKIP_CU_FLAG(depthSubPart, availableA, depthSubPartA, availableB, depthSubPartB);
        if DEBUG_CABAC then
            println(" SPLIT_CODING_UNIT_FLAG ==> ctxIdx := "+ctxIdx);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;   
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_SPLIT_CODING_UNIT_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" SPLIT_CODING_UNIT_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_PRED_MODE_FLAG
     *************************************************************************/
    procedure get_PRED_MODE_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    var
        uint(size=32) binString[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" PRED_MODE_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_PRED_MODE_FLAG, fifo);
        debinValue[0] := INTER + binString[0];
        if DEBUG_CABAC then
            //println(" PRED_MODE_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_PART_SIZE
     *************************************************************************/
    procedure get_PART_SIZE(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
       
        bool          isIntra,
        uint(size= 8) cu_log2CbSize,
        uint(size= 8) Log2MinCbSize,
        uint(size= 1) amp_enabled_flag
    )
    var
        uint(size=32) binString[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" PART_MODE ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
        
        //debinValue[0] := PART_NxN;                  // 000
        if binString[0] != 0 then
            debinValue[0] := PART_2Nx2N;            // 1
        elsif cu_log2CbSize = Log2MinCbSize then
            if isIntra then
                debinValue[0] := PART_NxN;
            else
            	
                decodeDecisionTop(1, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                if binString[0] != 0 then
                    debinValue[0] := PART_2NxN; // 01
                elsif cu_log2CbSize = 3 then
                    debinValue[0] := PART_Nx2N; // 00
                else
                    decodeDecisionTop(2, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                    if binString[0] != 0 then
                        debinValue[0] := PART_Nx2N; // 001
                    else
                    	debinValue[0] := PART_NxN;                  // 000
                    end
                end
            end
        else
            if amp_enabled_flag = 0 then
                decodeDecisionTop(1, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                if binString[0] != 0 then
                    debinValue[0] := PART_2NxN;
                else
                    debinValue[0] := PART_Nx2N;
                end
            else
                decodeDecisionTop(1, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                if binString[0] != 0 then
                    binString[0] := 0;
                    decodeDecisionTop(3, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                    if binString[0] = 1 then
                        debinValue[0] := PART_2NxN;       // 011
                    else
                        decodeBypassTop(binString, codIRange, codIOffset, fifo);
                        if binString[0] != 0 then
                            debinValue[0] := PART_2NxnD;  // 0101
                        else
                            debinValue[0] := PART_2NxnU;  // 0100
                        end
                    end
                else
                    decodeDecisionTop(3, binString, codIRange, codIOffset, ctxTable, SE_PART_MODE, fifo);
                    if binString[0] != 0 then
                        debinValue[0] := PART_Nx2N;       // 001
                    else
                        decodeBypassTop(binString, codIRange, codIOffset, fifo);
                        if binString[0] != 0 then
                            debinValue[0] := PART_nRx2N;  // 0001
                        else
                            debinValue[0] := PART_nLx2N;  // 0000
                        end
                    end
                end
            end
        end
        if DEBUG_CABAC then
            //println(" PART_MODE = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_PREV_INTRA_LUMA_PRED_FLAG
     *************************************************************************/
    procedure get_PREV_INTRA_LUMA_PRED_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" PREV_INTRA_LUMA_PRED_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_PREV_INTRA_LUMA_PRED_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" PREV_INTRA_LUMA_PRED_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_REM_INTRA_LUMA_PRED_MODE
     *************************************************************************/
    procedure get_REM_INTRA_LUMA_PRED_MODE(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
         int(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" REM_INTRA_LUMA_PRED_MODE ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBinsEP(5, debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" REM_INTRA_LUMA_PRED_MODE = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_MPM_IDX
     *************************************************************************/
    procedure get_MPM_IDX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
         uint(size=32) debinValue[1]
    )
    var
        uint(size= 8) binIdx := 0,
        uint(size= 1) debinCompleted[1] := [0],
        uint(size= 1) discard_suffix[1] := [0],       
        uint(size=32) binString[1]
    begin
        if DEBUG_CABAC then
            println(" MPM_IDX ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        while debinCompleted[0] = 0 do
            decodeBypassTop(binString, codIRange, codIOffset, fifo);
            debinTU(binString[0], binIdx, DEBIN_TU2, debinCompleted, debinValue, discard_suffix);
            binIdx := binIdx + 1;
        end
        if DEBUG_CABAC then
            //println(" MPM_IDX = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_INTRA_CHROMA_PRED_MODE
     *************************************************************************/
    procedure get_INTRA_CHROMA_PRED_MODE(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    var
        uint(size=32) binString[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" INTRA_CHROMA_PRED_MODE ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_INTRA_CHROMA_PRED_MODE, fifo);
        if binString[0] = 0 then
            debinValue[0] := 4;
        else
            decodeBinsEP(2, debinValue, codIRange, codIOffset, fifo);
        end
        if DEBUG_CABAC then
            //println(" INTRA_CHROMA_PRED_MODE = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SPLIT_TRANSFORM_FLAG
     *************************************************************************/
    procedure get_SPLIT_TRANSFORM_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 3) log2TransformBlockSize
    )
    begin
        if DEBUG_CABAC then
            println(" SPLIT_TRANSFORM_FLAG ==> "+(5 - log2TransformBlockSize));
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(5 - log2TransformBlockSize, debinValue, codIRange, codIOffset, ctxTable, SE_SPLIT_TRANSFORM_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" SPLIT_TRANSFORM_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_CBF_LUMA
     *************************************************************************/
    procedure get_CBF_LUMA(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 3) trafoDepth
    )
    var
        uint(size= 9) ctxIdx = if (trafoDepth = 0) then 1 else 0 end
    begin
        if DEBUG_CABAC then
            println(" CBF_LUMA ==> "+ctxIdx);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_CBF_LUMA, fifo);
        if DEBUG_CABAC then
            //println(" CBF_LUMA = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_CBF_CB_CR
     *************************************************************************/
    procedure get_CBF_CB_CR(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 3) trafoDepth
    )
    begin
        if DEBUG_CABAC then
            println(" CBF_CB_CR ==> "+trafoDepth);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(trafoDepth, debinValue, codIRange, codIOffset, ctxTable, SE_CBF_CB_CR, fifo);
        if DEBUG_CABAC then
            //println(" CBF_CB_CR = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_CU_QP_DELTA_ABS
     *************************************************************************/
    procedure get_CU_QP_DELTA_ABS(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    var
        uint(size= 8) prefixVal := 0,
        uint(size= 9) ctxIdx := 0,
        uint(size= 8) binIdx := 0,
        uint(size=32) binString[1] := [0],
        uint(size= 1) discard_suffix[1] := [0],
        uint(size= 1) debinCompleted[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" CU_QP_DELTA_ABS ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        while debinCompleted[0] = 0 do
            decodeDecisionTop(ctxIdx, binString, codIRange, codIOffset, ctxTable, SE_CU_QP_DELTA, fifo);
            debinTU(binString[0], binIdx, DEBIN_TU5, debinCompleted, debinValue, discard_suffix);
            ctxIdx := 1;
            binIdx := binIdx + 1;
        end
        prefixVal := debinValue[0];
        if prefixVal >= 5 then
            xReadEpExGolomb(0, debinValue, codIRange, codIOffset, fifo);
            debinValue[0] := debinValue[0] + prefixVal;
        end
        if DEBUG_CABAC then
            //println(" CU_QP_DELTA_ABS = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_CU_QP_DELTA_SIGN_FLAG
     *************************************************************************/
    procedure get_CU_QP_DELTA_SIGN_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" CU_QP_DELTA_SIGN_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBypassTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" CU_QP_DELTA_SIGN_FLAG = "+debinValue[0]);
        end
    end
       /*************************************************************************
     * get_TRANSFORM_SKIP_FLAG
     *************************************************************************/
    procedure get_TRANSFORM_SKIP_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) rc_TType       
    )
    var
        uint(size= 9) ctxIdx = if  rc_TType = TEXT_LUMA then 0 else 1 end
    begin
        if DEBUG_CABAC then
            println(" TRANSFORM_SKIP_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_TRANSFORM_SKIP_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" TRANSFORM_SKIP_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_LAST_SIGNIFICANT_COEFF_X_PREFIX
     *************************************************************************/
    procedure get_LAST_SIGNIFICANT_COEFF_X_PREFIX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) log2TrafoWidth,
        uint(size= 8) cIdx
    )
    var
        uint(size= 9) ctxIdx,
        uint(size= 8) binIdx := 0,
        uint(size=32) binString[1] := [0],
        uint(size= 1) discard_suffix[1] := [0],
        uint(size= 1) debinCompleted[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" LAST_SIGNIFICANT_COEFF_X_PREFIX ==> "+(1<<log2TrafoWidth));
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        while debinCompleted[0] = 0 do
            ctxIdx := context_93312(binIdx, log2TrafoWidth, cIdx);
            decodeDecisionTop(ctxIdx, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_X_PREFIX, fifo);
            debinTU(binString[0], binIdx, (log2TrafoWidth << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
            binIdx := binIdx + 1;
        end
        if DEBUG_CABAC then
            //println(" LAST_SIGNIFICANT_COEFF_X_PREFIX = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_LAST_SIGNIFICANT_COEFF_Y_PREFIX
     *************************************************************************/
    procedure get_LAST_SIGNIFICANT_COEFF_Y_PREFIX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) log2TrafoHeight,
        uint(size= 8) cIdx
    )
    var
        uint(size= 9) ctxIdx,
        uint(size= 8) binIdx := 0,
        uint(size=32) binString[1] := [0],
        uint(size= 1) discard_suffix[1] := [0],
        uint(size= 1) debinCompleted[1] := [0]
    begin
        if DEBUG_CABAC then
            println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX ==> "+(1<<log2TrafoHeight));
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end       
        while debinCompleted[0] = 0 do
            ctxIdx := context_93312(binIdx, log2TrafoHeight, cIdx);
            decodeDecisionTop(ctxIdx, binString, codIRange, codIOffset, ctxTable, SE_LAST_SIGNIFICANT_COEFF_Y_PREFIX, fifo);
            debinTU(binString[0], binIdx, (log2TrafoHeight << 1 ) - 2, debinCompleted, debinValue, discard_suffix);
            binIdx := binIdx + 1;
        end
        if DEBUG_CABAC then
            //println(" LAST_SIGNIFICANT_COEFF_Y_PREFIX = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX
     *************************************************************************/
    procedure get_LAST_SIGNIFICANT_COEFF_XY_SUFFIX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) prefix
    )
    begin
        if DEBUG_CABAC then
            println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBinsEP((prefix>>1)-1, debinValue, codIRange, codIOffset, fifo);       
        if DEBUG_CABAC then
            //println(" LAST_SIGNIFICANT_COEFF_XY_SUFFIX = "+debinValue[0]);
        end
    end   
    /*************************************************************************
     * get_CODED_SUB_BLOCK_FLAG
     *************************************************************************/
    procedure get_CODED_SUB_BLOCK_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],

        uint(size= 1) coded_sub_block_flag[8][8],
        uint(size=16) xC,
        uint(size=16) yC,
        uint(size= 8) cIdx,   
        uint(size= 8) log2TrafoSize
    )
    var
        uint(size= 9) ctxIdx[1]
    begin
        context_93313(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, ctxIdx);       
        if DEBUG_CABAC then
            println(" CODED_SUB_BLOCK_FLAG ==> "+(ctxIdx[0]&1));
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx[0], debinValue, codIRange, codIOffset, ctxTable, SE_CODED_SUB_BLOCK_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" CODED_SUB_BLOCK_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_SIGNIFICANT_COEFF_FLAG
     *************************************************************************/
    procedure get_SIGNIFICANT_COEFF_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],

        uint(size= 1) coded_sub_block_flag[8][8],
        uint(size=16) xC,
        uint(size=16) yC,
        uint(size= 8) cIdx,   
        uint(size= 8) log2TrafoSize,
        uint(size= 8) scanIdx
    )
    var
        uint(size= 9) ctxIdx[1]
    begin
        context_93314(coded_sub_block_flag, xC, yC, cIdx, log2TrafoSize, scanIdx, ctxIdx);       
        if DEBUG_CABAC then
            println(" SIGNIFICANT_COEFF_FLAG ==> "+ctxIdx[0]);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx[0], debinValue, codIRange, codIOffset, ctxTable, SE_SIGNIFICANT_COEFF_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" SIGNIFICANT_COEFF_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_COEFF_ABS_LEVEL_GREATER1_FLAG
     *************************************************************************/
    procedure get_COEFF_ABS_LEVEL_GREATER1_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
         int(size=32) debinValue[1],
       
        uint(size= 9) ctxIdx
    )
    begin
        if DEBUG_CABAC then
            println(" COEFF_ABS_LEVEL_GREATER1_FLAG ==> "+ctxIdx);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER1_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" COEFF_ABS_LEVEL_GREATER1_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_COEFF_ABS_LEVEL_GREATER2_FLAG
     *************************************************************************/
    procedure get_COEFF_ABS_LEVEL_GREATER2_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
       
        uint(size= 8) cIdx,
        uint(size= 8) ctxSet
    )
    var
        uint(size= 9) ctxIdx = ctxSet + if cIdx != 0 then 4 else 0 end
    begin
        if DEBUG_CABAC then
            println(" COEFF_ABS_LEVEL_GREATER2_FLAG ==> "+ctxIdx);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_COEFF_ABS_LEVEL_GREATER2_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" COEFF_ABS_LEVEL_GREATER2_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_COEFF_SIGN_FLAG
     *************************************************************************/
    procedure get_COEFF_SIGN_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) nb
    )
    begin
        if DEBUG_CABAC and nb != 0 then
            println(" COEFF_SIGN_FLAG ==> "+nb);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBinsEP(nb, debinValue, codIRange, codIOffset, fifo);       
        if DEBUG_CABAC and nb != 0  then
            //println(" COEFF_SIGN_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_COEFF_ABS_LEVEL
     *************************************************************************/
    procedure get_COEFF_ABS_LEVEL(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        //
        uint(size= 8) rParam
    )
    var
        uint(size=16) prefix := 0,
        uint(size=32) codeWord[1] := [1]
    begin
        if DEBUG_CABAC then
            println(" COEFF_ABS_LEVEL ==> "+rParam);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        while codeWord[0] = 1 do
            prefix      := prefix + 1;
            decodeBypassTop(codeWord, codIRange, codIOffset, fifo);
        end
        codeWord[0] := 1 - codeWord[0];
        prefix        := prefix - codeWord[0];
        if prefix < 3 then
            decodeBinsEP(rParam, codeWord, codIRange, codIOffset, fifo);
            debinValue[0] := (prefix<<rParam) + codeWord[0];
        else
            decodeBinsEP(prefix-3+rParam, codeWord, codIRange, codIOffset, fifo);
            debinValue[0] := (((1<<(prefix-3))+3-1)<<rParam) + codeWord[0];
        end
        if DEBUG_CABAC then
            //println(" COEFF_ABS_LEVEL = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_END_OF_SUB_STREAM_ONE_BIT
     *************************************************************************/
    procedure get_END_OF_SUB_STREAM_ONE_BIT(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" END_OF_SUB_STREAM_ONE_BIT ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeTerminateTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" END_OF_SUB_STREAM_ONE_BIT = "+debinValue[0]);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
       
    end
    /*************************************************************************
     * get_END_OF_SLICE_FLAG
     *************************************************************************/
    procedure get_END_OF_SLICE_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" END_OF_SLICE_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
       
        decodeTerminateTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" END_OF_SLICE_FLAG = "+debinValue[0]);
        end
        if CHECK_CABAC and debinValue[0] = 1 then
//            println(" END_OF_SLICE_FLAG ==>");
//            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
    end
    /*************************************************************************
     * get_SKIP_FLAG
     *************************************************************************/
    procedure get_SKIP_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
       
        uint(size= 1) skip_flag[CTB_ADDR_TS_MAX][2],
        uint(size=16) cu_x0,
        uint(size=16) cu_y0,
        bool leftFlag,
        bool upFlag
    )
    var
        uint(size= 9) ctxIdx,
        uint(size= 1) availableA = if leftFlag then skip_flag[cu_y0][1] else 0 end,
        uint(size= 1) availableB = if upFlag   then skip_flag[cu_x0][0] else 0 end
    begin
        ctxIdx      := availableA + availableB;
        if DEBUG_CABAC then
            println(" SKIP_FLAG ==> "+ctxIdx);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(ctxIdx, debinValue, codIRange, codIOffset, ctxTable, SE_SKIP_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" SKIP_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_MERGE_FLAG
     *************************************************************************/
    procedure get_MERGE_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" MERGE_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_MERGE_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" MERGE_FLAG = "+debinValue[0]);
        end
    end   
    /*************************************************************************
     * get_MERGE_IDX
     *************************************************************************/
    procedure get_MERGE_IDX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 5) MaxNumMergeCand
    )
    var
        uint(size=32) binString[1] := [0],
        uint(size= 8) binIdx := 1
    begin
        if DEBUG_CABAC then
            println(" MERGE_IDX ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        if MaxNumMergeCand > 1 then
            decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_MERGE_IDX, fifo);
            while binString[0] != 0 and binIdx < MaxNumMergeCand-1 do
                decodeBypassTop(binString, codIRange, codIOffset, fifo);
                binIdx := binIdx + 1;
            end
        end
        debinValue[0] := if binString[0] = 0 then binIdx - 1 else binIdx end;
        if DEBUG_CABAC then
            //println(" MERGE_IDX = "+debinValue[0]);
        end
    end   
    /*************************************************************************
     * get_INTER_PRED_IDC
     *************************************************************************/
    procedure get_INTER_PRED_IDC(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
       
        uint(size= 8) partMode,
        uint(size= 8) PbW,
        uint(size= 8) PbH,
        uint(size= 8) ctDepth
    )
    var
        //uint(size= 8) PbMax  = max(PbW,PbH),
        uint(size=32) binString[1] := [0]
    begin
       
        if DEBUG_CABAC then
            println(" INTER_PRED_IDC ==> "+ctDepth);
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        if PbW + PbH = 12 then
            decodeDecisionTop(4, binString, codIRange, codIOffset, ctxTable, SE_INTER_PRED_IDC, fifo);
            debinValue[0] := binString[0];
        else
            decodeDecisionTop(ctDepth, binString, codIRange, codIOffset, ctxTable, SE_INTER_PRED_IDC, fifo);
            debinValue[0] := binString[0];
            if debinValue[0] != 0 then
            	debinValue[0] := BI_PRED;
        	else
	        	decodeDecisionTop(4, binString, codIRange, codIOffset, ctxTable, SE_INTER_PRED_IDC, fifo);
	            debinValue[0] := binString[0];
	        end
        end

        if DEBUG_CABAC then
            //println(" INTER_PRED_IDC = "+debinValue[0]);
        end
    end   
    /*************************************************************************
     * get_REF_IDX_LX
     *************************************************************************/
    procedure get_REF_IDX_LX(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1],
        uint(size= 8) num_ref_idx_lx_active_minus1       
    )
    var
        uint(size=32) binString[1] := [0],
        uint(size= 8) binIdx := 1
    begin
       
        if DEBUG_CABAC then
            println(" REF_IDX_L0 ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeDecisionTop(0, binString, codIRange, codIOffset, ctxTable, SE_REF_IDX_L0, fifo);
        debinValue[0] := binString[0];
        if binString[0] = 1 and num_ref_idx_lx_active_minus1 > 1 then
            binString[0] := 0;
            decodeDecisionTop(1, binString, codIRange, codIOffset, ctxTable, SE_REF_IDX_L0, fifo);
            binIdx := binIdx + 1;
            while binString[0] != 0 and binIdx < num_ref_idx_lx_active_minus1 do
                decodeBypassTop(binString, codIRange, codIOffset, fifo);
                binIdx := binIdx + 1;
            end
            debinValue[0] := if binString[0] = 0 then binIdx - 1 else binIdx end;
        end
        if DEBUG_CABAC then
            //println(" REF_IDX_L0 = "+debinValue[0]);
        end
    end   
    /*************************************************************************
     * get_PCM_FLAG
     *************************************************************************/
    procedure get_PCM_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" PCM_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeTerminateTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" PCM_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_ABS_MVD_GREATER0_FLAG
     *************************************************************************/
    procedure get_ABS_MVD_GREATER0_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" ABS_MVD_GREATER0_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_ABS_MVD_GREATER0_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" ABS_MVD_GREATER0_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_ABS_MVD_GREATER1_FLAG
     *************************************************************************/
    procedure get_ABS_MVD_GREATER1_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" ABS_MVD_GREATER1_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(1, debinValue, codIRange, codIOffset, ctxTable, SE_ABS_MVD_GREATER0_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" ABS_MVD_GREATER1_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_ABS_MVD_MINUS2
     *************************************************************************/
    procedure get_ABS_MVD_MINUS2(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" ABS_MVD_MINUS2 ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        xReadEpExGolomb(1, debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" ABS_MVD_MINUS2 = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_MVD_SIGN_FLAG
     *************************************************************************/
    procedure get_MVD_SIGN_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" MVD_SIGN_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        decodeBypassTop(debinValue, codIRange, codIOffset, fifo);
        if DEBUG_CABAC then
            //println(" MVD_SIGN_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_MVP_LX_FLAG
     *************************************************************************/
    procedure get_MVP_LX_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" MVP_LX_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_MVP_LX_FLAG, fifo);       
        if DEBUG_CABAC then
            //println(" MVP_LX_FLAG = "+debinValue[0]);
        end
    end
    /*************************************************************************
     * get_NO_RESIDUAL_SYNTAX_FLAG
     *************************************************************************/
    procedure get_NO_RESIDUAL_SYNTAX_FLAG(
        uint(size= 9) codIRange[1],
        uint(size=16) codIOffset[1],
        uint(size= 9) ctxTable[NB_MAX_SE][NB_MAX_NUM_CTX],
        uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL],
        uint(size=32) debinValue[1]
    )
    begin
        if DEBUG_CABAC then
            println(" NO_RESIDUAL_SYNTAX_FLAG ==>");
            println("codIRange := "+codIRange[0]+ " codIOffset := " +codIOffset[0]);
        end
        debinValue[0] := 0;
        decodeDecisionTop(0, debinValue, codIRange, codIOffset, ctxTable, SE_NO_RESIDUAL_SYNTAX_FLAG, fifo);
        if DEBUG_CABAC then
            //println(" NO_RESIDUAL_SYNTAX_FLAG = "+debinValue[0]);
        end
    end
end
	
