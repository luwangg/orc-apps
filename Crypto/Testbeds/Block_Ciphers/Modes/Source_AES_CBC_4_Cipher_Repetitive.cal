/**
 * This FU is part of the testbed of a CAL implementation of AES (Rijndael) running at CCB mode.
 * It sends a key, an inialization vector, a sequence of plaintext and the golden response (ciphertext) for the enciphers in CFB mode.
 * The test vectors and golden responses are taken from the following reference:
 * Morris Dworkin, "Recommendation for Block Cipher Modes of Operation: Methods and Techniques,"
 *  				NIST Special Publication 800-38A, December 2001
 * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
 * 
 * FU ID: Source_AES_CBC_4_Cipher
 * Five output ports:
 *   1) uint(size=8) OP1_IV: the initialization vector (counter)
 *   2) uint(size=8) OP2_KeySize: the key size
 *   3) uint(size=8) OP3_Key: the key
 *   4) uint(size=8) OP4_PT: the plaintext
 *   5) uint(size=8) OP5_GR: the golden response
 *
 * Developers: Junaid Jameel Ahmad @ Uni-Konstanz 2010
 */

package Block_Ciphers.Modes;

actor Source_AES_CBC_4_Cipher_Repetitive () ==> uint(size=8) OP1_IV, uint(size=8) OP2_KeySize, uint(size=8) OP3_Key, 
									 uint(size=8) OP4_PT1, uint(size=8) OP4_PT2, uint(size=8) OP4_PT3, uint(size=8) OP4_PT4,  
									 uint(size=8) OP5_GR:

	// Test vectors for AES-128 (F.2.1 CBC-AES128.Encrypt).
	int KEY_SIZE = 16;
	List(type:uint(size=8), size=KEY_SIZE) k = [ // Key
		0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
	];

	List(type:uint(size=8), size=16) iv = [ // Initialization vector: One block
		0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
	];
	
	int TEXT_SIZE = 192;
	List(type:uint(size=8), size=TEXT_SIZE) pt = [ // Plaintext: Multiple blocks
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,		
		0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
		0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51
	];
	List(type:uint(size=8), size=TEXT_SIZE) gr = [ // Golden response (Ciphertext)	
		0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46,0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d,
		0x50,0x86,0xcb,0x9b,0x50,0x72,0x19,0xee,0x95,0xdb,0x11,0x3a,0x91,0x76,0x78,0xb2,
		0xe4,0x83,0x06,0x2b,0x2c,0x69,0x89,0xaf,0x61,0x7e,0x6f,0xc1,0x8f,0x22,0x39,0xfa,
		0x73,0xf9,0xc0,0xcc,0x96,0x88,0x0a,0x11,0x00,0x82,0xda,0x1d,0xb3,0x29,0x45,0x77,
		0xd8,0x14,0x7b,0xa4,0x62,0x69,0xbd,0x5b,0x8e,0x18,0x17,0x62,0x3f,0xe2,0x2d,0x40,
		0x19,0x4c,0xc1,0x0d,0x00,0xe1,0x11,0x27,0x28,0x76,0xe0,0xfd,0x8b,0x2f,0x3b,0xee,
		0x13,0xb3,0xf9,0x84,0x76,0x49,0x2c,0xfa,0xdf,0x53,0xcb,0x42,0x22,0xb4,0x46,0x6b,
		0x69,0xa6,0x8a,0x00,0x06,0xd7,0xe6,0x53,0x28,0xb2,0x07,0x0b,0x22,0x8d,0x40,0xfd,
		0x6b,0x35,0x96,0x5c,0x5d,0x60,0x28,0xe2,0x2b,0x6c,0x1e,0xd1,0x98,0x65,0x9e,0x6d,
		0x06,0x5f,0x0a,0x93,0xe3,0x29,0xf6,0xb8,0x6d,0xa2,0x94,0x4b,0x9d,0xbe,0x76,0xd6,
		0xe9,0xa4,0x7e,0xd9,0x82,0xba,0x3c,0x0b,0xd3,0x4c,0x83,0xfa,0x86,0xa7,0xa0,0xef,
		0x3f,0x6a,0x7e,0xbf,0x20,0x36,0x5b,0xb5,0x37,0xe0,0xa2,0x5b,0x2e,0x8a,0x11,0xbc		
	];

	sendInit:
	action ==> OP1_IV:[iv] repeat 16,
               OP2_KeySize:[KEY_SIZE],
               OP3_Key:[k] repeat KEY_SIZE
    end
    
    uint(size=64) numBlocks := 0;
    uint(size=64) packagesCounter := 0;
    uint(size=64) numPackages := 1;
     
    sendDataBlock:
    action ==>    
               OP4_PT1:[[pt[offset1+i]: for int i in 0 .. 15]] repeat 16,
               OP4_PT2:[[pt[offset2+i]: for int i in 0 .. 15]] repeat 16,
               OP4_PT3:[[pt[offset3+i]: for int i in 0 .. 15]] repeat 16,
               OP4_PT4:[[pt[offset4+i]: for int i in 0 .. 15]] repeat 16,               
               OP5_GR:[[gr[offset1+i]: for int i in 0 .. 63]] repeat 16*4
               
   //guard numBlocks < 12 
    guard packagesCounter < numPackages                          
    var
    	int offset1 := numBlocks * 16,
    	int offset2 := numBlocks * 16 + 16,
    	int offset3 := numBlocks * 16 + 16 * 2,
    	int offset4 := numBlocks * 16 + 16 * 3
    do    
    	numBlocks := numBlocks + 4;
    	
    	if (numBlocks = 12) then
    		numBlocks := 0;
    		packagesCounter := packagesCounter + 1;
    	end
    end
    
    schedule fsm send_init:
    	send_init (sendInit) --> send_blocks;
    	send_blocks (sendDataBlock) --> send_blocks;
    end
end
