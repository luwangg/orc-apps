/**
 * This FU gives implementation of Cipher Block Chaining (CBC) mode of block ciphers in RVC-CAL.
 * 
 * FU ID: CBC
 * One actor parameter:
 *   1) uint BLOCK_SIZE: Block size of the underlying block cipher in bytes (default: 16 = 128 bits)
 * Three inputs ports:
 *   1) uint(size=8) IP1_IV: Initial vector
 *   2) uint(size=8) IP2_IT: Input text block
 *   3) uint(size=8) IP3_FT: Feedback text block
 * One output port:
 *   1) uint(size=8) OP: Output text block
 * 
 * How this FU should be connected with a block encipher:
 * CBC.OP ==> BlockEncipher.Plaintext
 * BlockEncipher.Ciphertext ==> CBC.IP3_FT 
 * Plaintext ==> CBC.IP2_IT 
 * BlockEncipher.Ciphertext ==> Ciphertext 
 * 
 * How this FU should be connected with a block decipher:
 * BlockDecipher.Plaintext ==> CBC.IP2_IT 
 * Ciphertext ==> BlockDecipher.Ciphertext
 *            ==> CBC.IP3_FT
 * CBC.OP ==> Plaintext 
 * 
 * Developers: Junaid Jameel Ahmad, Shujun Li @ Uni-Konstanz 2010 
 * Last Modified: 03.12.2015
 */

package Block_Ciphers.Modes;

actor CBC(uint BLOCK_SIZE=16) uint(size=8) IP1_IV, uint(size=8) IP2_IT, uint(size=8) IP3_FT 
	==> uint(size=8) OP:
	
	// Step index controlling firings of different actions.
	int step_idx := 0;

	readIV:
	action IP1_IV:[iv] repeat BLOCK_SIZE, IP2_IT:[pt] repeat BLOCK_SIZE ==> OP:[[iv[i] ^ pt[i]: for int i in 0 .. BLOCK_SIZE - 1]] repeat BLOCK_SIZE
	guard step_idx = 0
	do
		step_idx := 1;
	end
	
	// Read the input text, XOR it with the feedback text and output the result.
	action IP2_IT:[pt] repeat BLOCK_SIZE, IP3_FT:[ft] repeat BLOCK_SIZE ==> OP:[[pt[i] ^ ft[i]: for int i in 0 .. BLOCK_SIZE - 1]] repeat BLOCK_SIZE
	guard step_idx = 1
	end

end
